This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
android/
  app/
    src/
      androidTest/
        java/
          com/
            getcapacitor/
              myapp/
                ExampleInstrumentedTest.java
      main/
        java/
          io/
            ionic/
              starter/
                MainActivity.java
        res/
          drawable/
            ic_launcher_background.xml
          drawable-v24/
            ic_launcher_foreground.xml
          layout/
            activity_main.xml
          mipmap-anydpi-v26/
            ic_launcher_round.xml
            ic_launcher.xml
          values/
            ic_launcher_background.xml
            strings.xml
            styles.xml
          xml/
            file_paths.xml
        AndroidManifest.xml
      test/
        java/
          com/
            getcapacitor/
              myapp/
                ExampleUnitTest.java
    .gitignore
    build.gradle
    capacitor.build.gradle
    proguard-rules.pro
  gradle/
    wrapper/
      gradle-wrapper.properties
  .gitignore
  build.gradle
  capacitor.settings.gradle
  gradle.properties
  gradlew
  gradlew.bat
  settings.gradle
  variables.gradle
src/
  app/
    components/
      sidemenu/
        sidemenu.component.html
        sidemenu.component.scss
        sidemenu.component.spec.ts
        sidemenu.component.ts
    pages/
      album/
        album.page.html
        album.page.spec.ts
        album.page.ts
      apariencia/
        apariencia.page.html
        apariencia.page.scss
        apariencia.page.spec.ts
        apariencia.page.ts
      chat/
        chat.page.html
        chat.page.scss
        chat.page.spec.ts
        chat.page.ts
      conf/
        conf.page.html
        conf.page.scss
        conf.page.spec.ts
        conf.page.ts
      friends/
        friends.page.html
        friends.page.scss
        friends.page.spec.ts
        friends.page.ts
      home/
        home.page.html
        home.page.scss
        home.page.spec.ts
        home.page.ts
      login/
        login.page.html
        login.page.spec.ts
        login.page.ts
      signin/
        signin.page.html
        signin.page.spec.ts
        signin.page.ts
      tabs/
        tabs.page.html
        tabs.page.spec.ts
        tabs.page.ts
    services/
      facades/
        audius.facade.spec.ts
        audius.facade.ts
        users.facade.spec.ts
        users.facade.ts
      requests/
        audius.request.spec.ts
        audius.request.ts
        users.request.spec.ts
        users.request.ts
      config.service.spec.ts
      config.service.ts
      tema.service.spec.ts
      tema.service.ts
    app.component.html
    app.component.spec.ts
    app.component.ts
    app.routes.ts
  assets/
    shapes.svg
  environments/
    environment.prod.ts
    environment.ts
  theme/
    variables.scss
  global.scss
  index.html
  main.ts
  polyfills.ts
  test.ts
  zone-flags.ts
.browserslistrc
.editorconfig
.eslintrc.json
.gitignore
angular.json
capacitor.config.ts
firebase.json
ionic.config.json
karma.conf.js
package.json
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.spec.json

================================================================
Files
================================================================

================
File: android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java
================
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import android.content.Context;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {

    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();

        assertEquals("com.getcapacitor.app", appContext.getPackageName());
    }
}

================
File: android/app/src/main/java/io/ionic/starter/MainActivity.java
================
package io.ionic.starter;

import com.getcapacitor.BridgeActivity;

public class MainActivity extends BridgeActivity {}

================
File: android/app/src/main/res/drawable/ic_launcher_background.xml
================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillColor="#26A69A"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
</vector>

================
File: android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml
================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillType="evenOdd"
        android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="78.5885"
                android:endY="90.9159"
                android:startX="48.7653"
                android:startY="61.0927"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1" />
</vector>

================
File: android/app/src/main/res/layout/activity_main.xml
================
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <WebView
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>

================
File: android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

================
File: android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>

================
File: android/app/src/main/res/values/ic_launcher_background.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#FFFFFF</color>
</resources>

================
File: android/app/src/main/res/values/strings.xml
================
<?xml version='1.0' encoding='utf-8'?>
<resources>
    <string name="app_name">Amuzik</string>
    <string name="title_activity_main">Amuzik</string>
    <string name="package_name">io.ionic.starter</string>
    <string name="custom_url_scheme">io.ionic.starter</string>
</resources>

================
File: android/app/src/main/res/values/styles.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <style name="AppTheme.NoActionBar" parent="Theme.AppCompat.DayNight.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:background">@null</item>
    </style>


    <style name="AppTheme.NoActionBarLaunch" parent="Theme.SplashScreen">
        <item name="android:background">@drawable/splash</item>
    </style>
</resources>

================
File: android/app/src/main/res/xml/file_paths.xml
================
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="my_images" path="." />
    <cache-path name="my_cache_images" path="." />
</paths>

================
File: android/app/src/main/AndroidManifest.xml
================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

        <activity
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|locale|smallestScreenSize|screenLayout|uiMode|navigation"
            android:name=".MainActivity"
            android:label="@string/title_activity_main"
            android:theme="@style/AppTheme.NoActionBarLaunch"
            android:launchMode="singleTask"
            android:exported="true">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

        </activity>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths"></meta-data>
        </provider>
    </application>

    <!-- Permissions -->

    <uses-permission android:name="android.permission.INTERNET" />
</manifest>

================
File: android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java
================
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {

    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}

================
File: android/app/.gitignore
================
/build/*
!/build/.npmkeep

================
File: android/app/build.gradle
================
apply plugin: 'com.android.application'

android {
    namespace "io.ionic.starter"
    compileSdk rootProject.ext.compileSdkVersion
    defaultConfig {
        applicationId "io.ionic.starter"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        aaptOptions {
             // Files and dirs to omit from the packaged assets dir, modified to accommodate modern web apps.
             // Default: https://android.googlesource.com/platform/frameworks/base/+/282e181b58cf72b6ca770dc7ca5f91f135444502/tools/aapt/AaptAssets.cpp#61
            ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:.*:!CVS:!thumbs.db:!picasa.ini:!*~'
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

repositories {
    flatDir{
        dirs '../capacitor-cordova-android-plugins/src/main/libs', 'libs'
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation "androidx.appcompat:appcompat:$androidxAppCompatVersion"
    implementation "androidx.coordinatorlayout:coordinatorlayout:$androidxCoordinatorLayoutVersion"
    implementation "androidx.core:core-splashscreen:$coreSplashScreenVersion"
    implementation project(':capacitor-android')
    testImplementation "junit:junit:$junitVersion"
    androidTestImplementation "androidx.test.ext:junit:$androidxJunitVersion"
    androidTestImplementation "androidx.test.espresso:espresso-core:$androidxEspressoCoreVersion"
    implementation project(':capacitor-cordova-android-plugins')
}

apply from: 'capacitor.build.gradle'

try {
    def servicesJSON = file('google-services.json')
    if (servicesJSON.text) {
        apply plugin: 'com.google.gms.google-services'
    }
} catch(Exception e) {
    logger.info("google-services.json not found, google-services plugin not applied. Push Notifications won't work")
}

================
File: android/app/capacitor.build.gradle
================
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN

android {
  compileOptions {
      sourceCompatibility JavaVersion.VERSION_21
      targetCompatibility JavaVersion.VERSION_21
  }
}

apply from: "../capacitor-cordova-android-plugins/cordova.variables.gradle"
dependencies {
    implementation project(':capacitor-app')
    implementation project(':capacitor-haptics')
    implementation project(':capacitor-keyboard')
    implementation project(':capacitor-splash-screen')
    implementation project(':capacitor-status-bar')

}


if (hasProperty('postBuildExtras')) {
  postBuildExtras()
}

================
File: android/app/proguard-rules.pro
================
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

================
File: android/gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

================
File: android/.gitignore
================
# Using Android gitignore template: https://github.com/github/gitignore/blob/HEAD/Android.gitignore

# Built application files
*.apk
*.aar
*.ap_
*.aab

# Files for the ART/Dalvik VM
*.dex

# Java class files
*.class

# Generated files
bin/
gen/
out/
#  Uncomment the following line in case you need and you don't have the release build type files in your app
# release/

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Proguard folder generated by Eclipse
proguard/

# Log Files
*.log

# Android Studio Navigation editor temp files
.navigation/

# Android Studio captures folder
captures/

# IntelliJ
*.iml
.idea/workspace.xml
.idea/tasks.xml
.idea/gradle.xml
.idea/assetWizardSettings.xml
.idea/dictionaries
.idea/libraries
# Android Studio 3 in .gitignore file.
.idea/caches
.idea/modules.xml
# Comment next line if keeping position of elements in Navigation Editor is relevant for you
.idea/navEditor.xml

# Keystore files
# Uncomment the following lines if you do not want to check your keystore files in.
#*.jks
#*.keystore

# External native build folder generated in Android Studio 2.2 and later
.externalNativeBuild
.cxx/

# Google Services (e.g. APIs or Firebase)
# google-services.json

# Freeline
freeline.py
freeline/
freeline_project_description.json

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots
fastlane/test_output
fastlane/readme.md

# Version control
vcs.xml

# lint
lint/intermediates/
lint/generated/
lint/outputs/
lint/tmp/
# lint/reports/

# Android Profiling
*.hprof

# Cordova plugins for Capacitor
capacitor-cordova-android-plugins

# Copied web assets
app/src/main/assets/public

# Generated Config files
app/src/main/assets/capacitor.config.json
app/src/main/assets/capacitor.plugins.json
app/src/main/res/xml/config.xml

================
File: android/build.gradle
================
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.7.2'
        classpath 'com.google.gms:google-services:4.4.2'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

apply from: "variables.gradle"

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

================
File: android/capacitor.settings.gradle
================
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
include ':capacitor-android'
project(':capacitor-android').projectDir = new File('../node_modules/@capacitor/android/capacitor')

include ':capacitor-app'
project(':capacitor-app').projectDir = new File('../node_modules/@capacitor/app/android')

include ':capacitor-haptics'
project(':capacitor-haptics').projectDir = new File('../node_modules/@capacitor/haptics/android')

include ':capacitor-keyboard'
project(':capacitor-keyboard').projectDir = new File('../node_modules/@capacitor/keyboard/android')

include ':capacitor-splash-screen'
project(':capacitor-splash-screen').projectDir = new File('../node_modules/@capacitor/splash-screen/android')

include ':capacitor-status-bar'
project(':capacitor-status-bar').projectDir = new File('../node_modules/@capacitor/status-bar/android')

================
File: android/gradle.properties
================
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true

================
File: android/gradlew
================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

================
File: android/gradlew.bat
================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

================
File: android/settings.gradle
================
include ':app'
include ':capacitor-cordova-android-plugins'
project(':capacitor-cordova-android-plugins').projectDir = new File('./capacitor-cordova-android-plugins/')

apply from: 'capacitor.settings.gradle'

================
File: android/variables.gradle
================
ext {
    minSdkVersion = 23
    compileSdkVersion = 35
    targetSdkVersion = 35
    androidxActivityVersion = '1.9.2'
    androidxAppCompatVersion = '1.7.0'
    androidxCoordinatorLayoutVersion = '1.2.0'
    androidxCoreVersion = '1.15.0'
    androidxFragmentVersion = '1.8.4'
    coreSplashScreenVersion = '1.0.1'
    androidxWebkitVersion = '1.12.1'
    junitVersion = '4.13.2'
    androidxJunitVersion = '1.2.1'
    androidxEspressoCoreVersion = '3.6.1'
    cordovaAndroidVersion = '10.1.1'
}

================
File: src/app/components/sidemenu/sidemenu.component.html
================
<ion-menu side="start" menuId="main-menu" contentId="main-content" type="push">
  <ion-header>
    <ion-toolbar>
      <ion-title>Menú</ion-title>
    </ion-toolbar>
  </ion-header>
  
  <ion-content>
    <ion-list>
      <ion-menu-toggle auto-hide="false">
        <ion-item button (click)="goToSettings()">
          <ion-icon slot="start" name="settings-outline"></ion-icon>
          <ion-label>Configuración</ion-label>
        </ion-item>
      </ion-menu-toggle>
      
      <ion-menu-toggle auto-hide="false">
        <ion-item button (click)="goToAppearance()">
          <ion-icon slot="start" name="brush-outline"></ion-icon>
          <ion-label>Apariencia</ion-label>
        </ion-item>
      </ion-menu-toggle>

      <ion-menu-toggle auto-hide="false">
        <ion-item button (click)="goToHome()">
          <ion-icon slot="start" name="home-outline"></ion-icon>
          <ion-label>Inicio</ion-label>
        </ion-item>
      </ion-menu-toggle>
    </ion-list>
  </ion-content>
</ion-menu>

================
File: src/app/components/sidemenu/sidemenu.component.scss
================
/* src/app/components/side-menu/side-menu.component.scss */
ion-menu {
    --width: 280px;
    
    ion-footer {
      ion-item {
        margin-bottom: 8px;
        --border-radius: 4px;
        margin-left: 8px;
        margin-right: 8px;
      }
    }
  }

================
File: src/app/components/sidemenu/sidemenu.component.spec.ts
================
import { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { SidemenuComponent } from './sidemenu.component';

describe('SidemenuComponent', () => {
  let component: SidemenuComponent;
  let fixture: ComponentFixture<SidemenuComponent>;

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      declarations: [ SidemenuComponent ],
      imports: [IonicModule.forRoot()]
    }).compileComponents();

    fixture = TestBed.createComponent(SidemenuComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  }));

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/components/sidemenu/sidemenu.component.ts
================
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import {
  IonMenu,
  IonHeader,
  IonToolbar,
  IonTitle,
  IonContent,
  IonList,
  IonItem,
  IonIcon,
  IonLabel,
  IonMenuToggle,
  IonFooter,
} from '@ionic/angular/standalone';
import { addIcons } from 'ionicons';
import { 
  settingsOutline, 
  brushOutline,
  moonOutline, 
  sunnyOutline, homeOutline } from 'ionicons/icons';
import { Router } from '@angular/router';

@Component({
  selector: 'app-side-menu',
  templateUrl: './sidemenu.component.html',
  styleUrls: ['./sidemenu.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    IonMenu,
    IonHeader,
    IonToolbar,
    IonTitle,
    IonContent,
    IonList,
    IonItem,
    IonIcon,
    IonLabel,
    IonMenuToggle
]
})
export class SidemenuComponent implements OnInit {
  darkMode = false;

  constructor(private router: Router) {
    // Registrar iconos
    addIcons({settingsOutline,brushOutline,homeOutline,moonOutline,sunnyOutline});
    
    // Cargar preferencia de tema
    const savedTheme = localStorage.getItem('darkMode');
    this.darkMode = savedTheme === 'true';
  }

  ngOnInit() {}

  // Navegar a configuración
  goToSettings() {
    this.router.navigate(['/conf']);
  }

  // Navegar a apariencia
  goToAppearance() {
    this.router.navigate(['/apariencia']);
  }

  goToHome() {
    this.router.navigate(['/home']);
  }
}

================
File: src/app/pages/album/album.page.html
================
<ion-header [translucent]="true">
  <ion-toolbar>
    <ion-title>album</ion-title>
  </ion-toolbar>
</ion-header>

<ion-content [fullscreen]="true">
  <ion-header collapse="condense">
    <ion-toolbar>
      <ion-title size="large">album</ion-title>
    </ion-toolbar>
  </ion-header>
</ion-content>

================
File: src/app/pages/album/album.page.spec.ts
================
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { AlbumPage } from './album.page';

describe('AlbumPage', () => {
  let component: AlbumPage;
  let fixture: ComponentFixture<AlbumPage>;

  beforeEach(() => {
    fixture = TestBed.createComponent(AlbumPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/pages/album/album.page.ts
================
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { IonContent, IonHeader, IonTitle, IonToolbar } from '@ionic/angular/standalone';

@Component({
  selector: 'app-album',
  templateUrl: './album.page.html',
  styleUrls: ['./album.page.scss'],
  standalone: true,
  imports: [IonContent, IonHeader, IonTitle, IonToolbar, CommonModule, FormsModule]
})
export class AlbumPage implements OnInit {

  constructor() { }

  ngOnInit() {
  }

}

================
File: src/app/pages/apariencia/apariencia.page.html
================
<ion-header>
  <ion-toolbar>
    <ion-buttons slot="start">
      <ion-back-button defaultHref="/ajustes"></ion-back-button>
    </ion-buttons>
    <ion-title color="primary">Apariencia</ion-title>
  </ion-toolbar>
</ion-header>

<ion-content class="ion-padding">
  <ion-card>
    <ion-card-header>
      <ion-card-title color="primary">
        <ion-icon name="contrast-outline"></ion-icon>
        Modo de Pantalla
      </ion-card-title>
    </ion-card-header>
    <ion-card-content>
      <ion-segment [(ngModel)]="modoPreferido" (ionChange)="cambiarModoManual(modoPreferido)">
        <ion-segment-button value="sistema">
          <ion-icon name="desktop-outline"></ion-icon>
          <ion-label>Automático</ion-label>
        </ion-segment-button>
        <ion-segment-button value="claro">
          <ion-icon name="sunny-outline"></ion-icon>
          <ion-label>Claro</ion-label>
        </ion-segment-button>
        <ion-segment-button value="oscuro">
          <ion-icon name="moon-outline"></ion-icon>
          <ion-label>Oscuro</ion-label>
        </ion-segment-button>
      </ion-segment>
      
      <p class="ion-padding-top ion-text-center">
        <ng-container *ngIf="modoPreferido === 'sistema'">
          Usando la configuración del sistema (actualmente: {{ modoOscuro ? 'Oscuro' : 'Claro' }})
        </ng-container>
        <ng-container *ngIf="modoPreferido !== 'sistema'">
          Usando el modo {{ modoPreferido }}
        </ng-container>
      </p>
    </ion-card-content>
  </ion-card>

  <ion-card>
    <ion-card-header>
      <ion-card-title color="primary">
        <ion-icon name="color-palette-outline"></ion-icon>
        Tema de Color
      </ion-card-title>
    </ion-card-header>
    <ion-card-content>
      <ion-grid>
        <ion-row>
          <ng-container *ngFor="let tema of temas">
            <ion-col size="4" class="ion-text-center">
              <div 
                class="tema-preview" 
                [ngClass]="[obtenerClasePrevia(tema), obtenerTemaActualId() === tema.id ? 'selected' : '']"
                (click)="seleccionarTema(tema)">
                <div *ngIf="obtenerTemaActualId() === tema.id" class="check-icon">
                  <ion-icon name="checkmark-circle-outline"></ion-icon>
                </div>
              </div>
              <small>{{ tema.nombre }}</small>
            </ion-col>
          </ng-container>
        </ion-row>
      </ion-grid>
    </ion-card-content>
  </ion-card>

  <ion-card>
    <ion-card-header>
      <ion-card-title color="primary">
        <ion-icon name="text-outline"></ion-icon>
        Tamaño de Texto
      </ion-card-title>
    </ion-card-header>
    <ion-card-content>
      <ion-range 
        min="80" 
        max="140" 
        step="5" 
        snaps="true" 
        (ionChange)="updateFontSize($event)"
        [value]="100">
        <ion-icon name="text-outline" slot="start" style="font-size: 14px;"></ion-icon>
        <ion-icon name="text-outline" slot="end" style="font-size: 22px;"></ion-icon>
      </ion-range>
    </ion-card-content>
  </ion-card>

  <div class="ion-padding ion-text-center">
    <ion-button color="medium" (click)="restaurarConfiguracion()">
      <ion-icon name="close-outline" slot="start"></ion-icon>
      Restaurar valores predeterminados
    </ion-button>
  </div>

</ion-content>

================
File: src/app/pages/apariencia/apariencia.page.scss
================
.tema-preview {
  width: 100%;
  height: 60px;
  border-radius: 10px;
  margin-bottom: 8px;
  position: relative;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s, box-shadow 0.2s;
  
  &.selected {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  &:hover {
    transform: scale(1.05);
  }
}

// Clases para cada tema (versión light)
.theme-standard-light {
  background-color: #3880ff;
}

.theme-neutral-light {
  background-color: #666666;
}

.theme-pastel-green-light {
  background-color: #7acb7a;
}

.theme-pastel-blue-light {
  background-color: #7fb2d9;
}

.theme-pastel-purple-light {
  background-color: #c17fd9;
}

.theme-pastel-red-light {
  background-color: #e78787;
}

.theme-pastel-orange-light {
  background-color: #f2a76c;
}

// Clases para cada tema (versión dark)
.theme-standard-dark {
  background-color: #3171e0;
}

.theme-neutral-dark {
  background-color: #444444;
}

.theme-pastel-green-dark {
  background-color: #5a9d5a;
}

.theme-pastel-blue-dark {
  background-color: #5992b9;
}

.theme-pastel-purple-dark {
  background-color: #9f5fb9;
}

.theme-pastel-red-dark {
  background-color: #c76767;
}

.theme-pastel-orange-dark {
  background-color: #d28b4c;
}

.check-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  
  ion-icon {
    font-size: 28px;
    color: white;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 50%;
  }
}

================
File: src/app/pages/apariencia/apariencia.page.spec.ts
================
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { AparienciaPage } from './apariencia.page';

describe('AparienciaPage', () => {
  let component: AparienciaPage;
  let fixture: ComponentFixture<AparienciaPage>;

  beforeEach(() => {
    fixture = TestBed.createComponent(AparienciaPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/pages/apariencia/apariencia.page.ts
================
import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { 
  IonContent, 
  IonHeader, 
  IonTitle, 
  IonToolbar, 
  IonList, 
  IonItem, 
  IonLabel, 
  IonToggle, 
  IonIcon, 
  IonSelect, 
  IonSelectOption,
  IonRadioGroup,
  IonRadio,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardTitle,
  IonItemDivider,
  IonButton,
  IonGrid,
  IonRow,
  IonCol, 
  IonRange, 
  IonBackButton, 
  IonButtons,
  IonSegment,
  IonSegmentButton } from '@ionic/angular/standalone';
import { addIcons } from 'ionicons';
import { 
  contrastOutline, 
  colorPaletteOutline, 
  moonOutline, 
  sunnyOutline, 
  checkmarkCircleOutline, 
  textOutline, 
  closeOutline,
  desktopOutline } from 'ionicons/icons';
import { TemaService, TemaConfig, ModoTema } from 'src/app/services/tema.service';
import { Subscription } from 'rxjs';

interface Tema {
  id: string;
  nombre: string;
  colorClase: string;
  colorPrincipal: string;
  modoOscuro: boolean; 
}

@Component({
  selector: 'app-apariencia',
  templateUrl: './apariencia.page.html',
  styleUrls: ['./apariencia.page.scss'],
  standalone: true,
  imports: [
    IonButtons, 
    IonBackButton, 
    IonRange,
    IonContent,
    IonHeader,
    IonTitle,
    IonToolbar,
    CommonModule,
    FormsModule,
    IonItem,
    IonLabel,
    IonToggle,
    IonIcon,
    IonCard,
    IonCardContent,
    IonCardHeader,
    IonCardTitle,
    IonButton,
    IonGrid,
    IonRow,
    IonCol,
    IonSegment,
    IonSegmentButton
  ]
})
export class AparienciaPage implements OnInit, OnDestroy {
  temaActual: string = '';
  modoOscuro: boolean = false;  
  modoPreferido: ModoTema = 'sistema';
  temas: Tema[] = [];
  
  private temaSubscription: Subscription = new Subscription;
  private modoOscuroSubscription: Subscription = new Subscription;
  private preferenciaModoBrilloSubscription: Subscription = new Subscription;

  constructor(private temaService: TemaService) {
    addIcons({
      closeOutline,
      contrastOutline,
      colorPaletteOutline,
      checkmarkCircleOutline,
      textOutline,
      moonOutline,
      sunnyOutline,
      desktopOutline
    });
  }

  ngOnInit() {
    this.temas = this.temaService.temasDisponibles
      .filter(tema => ['green', 'blue', 'purple', 'red', 'orange','standard','neutral'].includes(tema.id))
      .map(tema => ({
        id: tema.id,
        nombre: tema.nombre,
        colorClase: tema.colorClase,
        colorPrincipal: tema.colorPrincipal,
        modoOscuro: false
      }));
    
    this.temaSubscription = this.temaService.temaActual$.subscribe(tema => {
      this.temaActual = tema;
    });
    this.modoOscuroSubscription = this.temaService.modoOscuro$.subscribe(modo => {
      this.modoOscuro = modo;
      
      this.temas.forEach(tema => {
        tema.modoOscuro = modo;
      });
    });
    
    this.preferenciaModoBrilloSubscription = this.temaService.preferenciaModoBrillo$.subscribe(modo => {
      this.modoPreferido = modo;
    });
  }

  ngOnDestroy() {
    if (this.temaSubscription) {
      this.temaSubscription.unsubscribe();
    }
    if (this.modoOscuroSubscription) {
      this.modoOscuroSubscription.unsubscribe();
    }
    if (this.preferenciaModoBrilloSubscription) {
      this.preferenciaModoBrilloSubscription.unsubscribe();
    }
  }

  seleccionarTema(tema: Tema) {
    this.temaService.cambiarTema(tema.id);
  }

  cambiarModoManual(modo: ModoTema) {
    this.temaService.cambiarPreferenciaModo(modo);
  }

  obtenerClasePrevia(tema: Tema): string {
    const sufijo = this.modoOscuro ? '-dark' : '-light';
    return `${tema.colorClase}${sufijo}`;
  }

  obtenerTemaActualId(): string {
    const temaActualNombre = this.temaActual.split('-light')[0].split('-dark')[0];
    
    for (const tema of this.temas) {
      if (temaActualNombre === tema.colorClase) {
        return tema.id;
      }
    }
    return '';
  }

  updateFontSize(event: CustomEvent) {
    const percentage = event.detail.value;
    document.documentElement.style.fontSize = `${percentage}%`;
    localStorage.setItem('font-size', percentage.toString());
  }

  restaurarConfiguracion() {
    this.temaService.restaurarConfiguracionPredeterminada();
    
    document.documentElement.style.fontSize = '100%';
    localStorage.removeItem('font-size');
  }
}

================
File: src/app/pages/chat/chat.page.html
================
<div class="ion-page">
  <ion-header [translucent]="true">
    <ion-toolbar>
      <ion-buttons slot="start">
        <ion-back-button defaultHref="/friends"></ion-back-button>
      </ion-buttons>
      <ion-title>{{ friend?.name }}</ion-title>
    </ion-toolbar>
  </ion-header>
  <ion-content [fullscreen]="true" #content>
    <div class="chat-container">
      <div *ngFor="let message of messages" [ngClass]="{'message-received': !message.isMe, 'message-sent': message.isMe}">
        <div class="message-bubble">
          <p>{{ message.text }}</p>
          <span class="message-time">{{ message.time | date:'shortTime' }}</span>
        </div>
      </div>
    </div>
  </ion-content>
  <ion-footer class="ion-no-border">
    <ion-toolbar>
      <div class="message-input-container">
        <ion-input 
          [(ngModel)]="newMessage" 
          placeholder="Escribe un mensaje..." 
          (keyup.enter)="sendMessage()"
        ></ion-input>
        <ion-button fill="clear" (click)="sendMessage()">
          <ion-icon name="send"></ion-icon>
        </ion-button>
      </div>
    </ion-toolbar>
  </ion-footer>
</div>

================
File: src/app/pages/chat/chat.page.scss
================
.chat-container {
  display: flex;
  flex-direction: column;
  padding: 10px;
  padding-bottom: 60px; /* Espacio adicional para evitar que el teclado oculte mensajes */
}

.message-received,
.message-sent {
  display: flex;
  margin-bottom: 10px;
  max-width: 80%;
}

.message-received {
  align-self: flex-start;
}

.message-sent {
  align-self: flex-end;
}

.message-bubble {
  padding: 10px 15px;
  border-radius: 20px;
  position: relative;
  
  p {
    margin: 0;
    padding-right: 40px;
  }
}

.message-received .message-bubble {
  background-color: var(--ion-color-secondary);
  color: #000;
}

.message-sent .message-bubble {
  background-color: var(--ion-color-primary);
  color: #fff;
}

.message-time {
  font-size: 0.7rem;
  opacity: 0.7;
  position: absolute;
  bottom: 7px;
  right: 10px;
}

.message-input-container {
  display: flex;
  align-items: center;
  padding: 5px 10px;
  background-color: #fff;
  color: #000;
  ion-input {
    --padding-start: 15px;
    --padding-end: 15px;
    --padding-top: 10px;
    --padding-bottom: 10px;
    --background: #f1f0f0;
    border-radius: 20px;
    margin-right: 10px;
  }
  
  ion-button {
    --padding-start: 0;
    --padding-end: 0;
    height: 40px;
    width: 40px;
  }
}

/* Estilos específicos para iOS */
:host-context(.ios) ion-footer {
  position: sticky;
  bottom: 0;
}

/* Para ambas plataformas - cuando el teclado está abierto */
ion-footer {
  z-index: 11; /* Asegura que el footer esté por encima */
}

/* Ajuste para pantallas pequeñas */
@media (max-height: 568px) {
  .chat-container {
    padding-bottom: 80px; /* Más espacio para dispositivos pequeños */
  }
}

================
File: src/app/pages/chat/chat.page.spec.ts
================
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ChatPage } from './chat.page';

describe('ChatPage', () => {
  let component: ChatPage;
  let fixture: ComponentFixture<ChatPage>;

  beforeEach(() => {
    fixture = TestBed.createComponent(ChatPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/pages/chat/chat.page.ts
================
import { Component, OnInit, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ActivatedRoute } from '@angular/router';
import { 
  IonContent, 
  IonHeader, 
  IonTitle, 
  IonToolbar, 
  IonButtons, 
  IonBackButton,
  IonFooter,
  IonInput,
  IonButton,
  IonIcon
} from '@ionic/angular/standalone';
import { addIcons } from 'ionicons';
import { send, arrowBack } from 'ionicons/icons';

interface Message {
  id: number;
  text: string;
  isMe: boolean;
  time: Date;
}

interface Friend {
  id: number;
  name: string;
  avatar: string;
}

@Component({
  selector: 'app-chat',
  templateUrl: './chat.page.html',
  styleUrls: ['./chat.page.scss'],
  standalone: true,
  imports: [
    CommonModule, 
    FormsModule,
    IonContent, 
    IonHeader, 
    IonTitle, 
    IonToolbar, 
    IonButtons, 
    IonBackButton,
    IonFooter,
    IonInput,
    IonButton,
    IonIcon
  ]
})
export class ChatPage implements OnInit {
  @ViewChild('content')
  content!: IonContent;
  
  friendId!: number;
  friend: Friend | null = null;
  newMessage: string = '';
  messages: Message[] = [];
  friends: Friend[] = [
    {
      id: 1,
      name: 'Juan Pérez',
      avatar: 'https://randomuser.me/api/portraits/men/1.jpg',
    },
    {
      id: 2,
      name: 'Ana López',
      avatar: 'https://randomuser.me/api/portraits/women/1.jpg',
    },
    {
      id: 3,
      name: 'Carlos García',
      avatar: 'https://randomuser.me/api/portraits/men/2.jpg',
    },
    {
      id: 4,
      name: 'Laura Martín',
      avatar: 'https://randomuser.me/api/portraits/women/2.jpg',
    },
  ];
  
  mockMessages: { [key: number]: Message[] } = {
    1: [
      { id: 1, text: 'Hola Juan, ¿cómo estás?', isMe: true, time: new Date(Date.now() - 3600000) },
      { id: 2, text: '¡Hola! Todo bien, ¿y tú?', isMe: false, time: new Date(Date.now() - 3500000) },
      { id: 3, text: 'Muy bien, gracias. ¿Qué tal el proyecto?', isMe: true, time: new Date(Date.now() - 3400000) }
    ],
    2: [
      { id: 1, text: 'Ana, ¿viste el email que envié?', isMe: true, time: new Date(Date.now() - 86400000) },
      { id: 2, text: 'Sí, ya lo revisé. Te responderé más tarde', isMe: false, time: new Date(Date.now() - 82800000) }
    ],
    3: [
      { id: 1, text: 'Hola Carlos, necesito los documentos', isMe: true, time: new Date(Date.now() - 172800000) },
      { id: 2, text: 'Te los envío mañana sin falta', isMe: false, time: new Date(Date.now() - 169200000) }
    ],
    4: [
      { id: 1, text: 'Laura, ¿asistirás a la reunión?', isMe: true, time: new Date(Date.now() - 259200000) },
      { id: 2, text: 'Sí, allí estaré', isMe: false, time: new Date(Date.now() - 255600000) },
      { id: 3, text: 'Perfecto, nos vemos entonces', isMe: true, time: new Date(Date.now() - 252000000) }
    ]
  };

  constructor(private route: ActivatedRoute) {
    addIcons({
      send,
      arrowBack
    });
  }

  ngOnInit() {
    this.route.params.subscribe(params => {
      this.friendId = +params['id'];
      this.loadFriendData();
      this.loadMessages();
    });
  }

  ionViewDidEnter() {
    this.scrollToBottom();
  }

  loadFriendData() {
    this.friend = this.friends.find(f => f.id === this.friendId) || null;
  }

  loadMessages() {
    this.messages = this.mockMessages[this.friendId] || [];
    
    const storageKey = `messages_${this.friendId}`;
    const savedMessages = localStorage.getItem(storageKey);
    
    if (savedMessages) {
      try {
        const parsedMessages = JSON.parse(savedMessages);
        
        parsedMessages.forEach((msg: any) => {
          msg.time = new Date(msg.time);
        });
        
        this.messages = parsedMessages;
      } catch (error) {
        console.error('Error al cargar mensajes:', error);
      }
    }
  }

  sendMessage() {
    if (this.newMessage.trim() === '') return;
    
    const newMsg: Message = {
      id: this.messages.length + 1,
      text: this.newMessage.trim(),
      isMe: true,
      time: new Date()
    };
    
    this.messages.push(newMsg);
    
    this.saveMessages();
    
    this.newMessage = '';
    
    this.scrollToBottom();
    
    this.simulateResponse();
  }

  simulateResponse() {
    setTimeout(() => {
      const responses = [
        'Ok, entendido',
        '¡Claro!',
        'Me parece bien',
        'Estoy de acuerdo',
        '¿En serio?',
        'Interesante, cuéntame más'
      ];
      
      const randomResponse = responses[Math.floor(Math.random() * responses.length)];
      
      const responseMsg: Message = {
        id: this.messages.length + 1,
        text: randomResponse,
        isMe: false,
        time: new Date()
      };
      
      this.messages.push(responseMsg);
      
      this.saveMessages();
      
      this.scrollToBottom();
    }, 1000);
  }

  saveMessages() {
    const storageKey = `messages_${this.friendId}`;
    localStorage.setItem(storageKey, JSON.stringify(this.messages));
  }

  scrollToBottom() {
    if (this.content) {
      setTimeout(() => {
        this.content.scrollToBottom(300);
      }, 100);
    }
  }
}

================
File: src/app/pages/conf/conf.page.html
================
<!-- conf.page.html -->
<ion-header [translucent]="true">
  <ion-toolbar>
    <ion-title color="primary">Configuración</ion-title>
    <ion-buttons slot="end">
      <ion-back-button defaultHref="/home"></ion-back-button>
    </ion-buttons>
  </ion-toolbar>
</ion-header>

<ion-content [fullscreen]="true" class="ion-padding">
  <ion-card>
    <ion-card-header>
      <ion-card-title color="primary">Perfil</ion-card-title>
    </ion-card-header>
    <ion-card-content>
      <div class="perfil-container">
        <ion-avatar>
          <img [src]="usuario.foto" alt="Foto de perfil">
        </ion-avatar>
        <div class="perfil-info">
          <h2>{{ usuario.nombre }}</h2>
          <p>{{ usuario.email }}</p>
          <ion-button size="small" fill="outline" (click)="editarPerfil()">Editar perfil</ion-button>
        </div>
      </div>
    </ion-card-content>
  </ion-card>

  <ion-list>
    <ion-item-divider>
      <ion-label>
        <span class="seccion-titulo">
          <ion-icon name="person-outline"></ion-icon>
          Ajustes de Cuenta
        </span>
      </ion-label>
    </ion-item-divider>
    <ion-item>
      <ion-icon slot="start" name="language-outline"></ion-icon>
      <ion-label>Idioma</ion-label>
      <ion-select [(ngModel)]="configuraciones.cuenta.idioma" interface="popover">
        <ion-select-option *ngFor="let idioma of idiomas" [value]="idioma.valor">{{idioma.texto}}</ion-select-option>
      </ion-select>
    </ion-item>
  </ion-list>

  <ion-list>
    <ion-item-divider>
      <ion-label>
        <span class="seccion-titulo">
          <ion-icon name="notifications-outline"></ion-icon>
          Notificaciones
        </span>
      </ion-label>
    </ion-item-divider>
    <ion-item>
      <ion-label>Notificaciones push</ion-label>
      <ion-toggle [(ngModel)]="configuraciones.notificaciones.push"></ion-toggle>
    </ion-item>
    <ion-item>
      <ion-label>Notificaciones por email</ion-label>
      <ion-toggle [(ngModel)]="configuraciones.notificaciones.email"></ion-toggle>
    </ion-item>
    <ion-item *ngIf="configuraciones.notificaciones.push || configuraciones.notificaciones.email">
      <ion-label>Sonido</ion-label>
      <ion-toggle [(ngModel)]="configuraciones.notificaciones.sonido"></ion-toggle>
    </ion-item>
    <ion-item *ngIf="configuraciones.notificaciones.push">
      <ion-label>Vibración</ion-label>
      <ion-toggle [(ngModel)]="configuraciones.notificaciones.vibracion"></ion-toggle>
    </ion-item>
  </ion-list>

  <ion-list>
    <ion-item-divider>
      <ion-label>
        <span class="seccion-titulo">
          <ion-icon name="settings-outline"></ion-icon>
          Configuración General
        </span>
      </ion-label>
    </ion-item-divider>
    <ion-item button detail="true" href="https://hmarort.github.io/amuzik-blog/">
      <ion-icon slot="start" name="help-circle-outline"></ion-icon>
      <ion-label>Ayuda y soporte</ion-label>
      <ion-icon slot="end" name="chevron-forward-outline"></ion-icon>
    </ion-item>
  </ion-list>

  <div class="accion-container">
    <ion-button expand="block" color="danger" (click)="cerrarSesion()">
      <ion-icon slot="start" name="log-out-outline"></ion-icon>
      Cerrar sesión
    </ion-button>
  </div>

  <div class="accion-container">
    <ion-button expand="block" (click)="guardarCambios()" [disabled]="!hayCambiosSinGuardar()">
      Guardar cambios
    </ion-button>
  </div>
</ion-content>

================
File: src/app/pages/conf/conf.page.scss
================
/* conf.page.scss */
.perfil-container {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 8px 0;
}

.perfil-info {
  flex: 1;
  
  h2 {
    margin-bottom: 2px;
    font-weight: 600;
  }
  
  p {
    margin-top: 0;
    margin-bottom: 12px;
    color: var(--ion-color-medium);
    font-size: 14px;
  }
}

ion-avatar {
  width: 64px;
  height: 64px;
}

.seccion-titulo {
  display: flex;
  align-items: center;
  gap: 8px;
  
  ion-icon {
    font-size: 18px;
  }
}

.accion-container {
  margin-top: 16px;
}

ion-item-divider {
  margin-top: 16px;
  --background: transparent;
  --padding-top: 8px;
  --padding-bottom: 8px;
  
  ion-label {
    margin: 0;
    font-weight: 600;
    color: var(--ion-color-primary);
  }
}

================
File: src/app/pages/conf/conf.page.spec.ts
================
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ConfPage } from './conf.page';

describe('ConfPage', () => {
  let component: ConfPage;
  let fixture: ComponentFixture<ConfPage>;

  beforeEach(() => {
    fixture = TestBed.createComponent(ConfPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/pages/conf/conf.page.ts
================
// conf.page.ts
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import {
  IonContent,
  IonHeader,
  IonTitle,
  IonToolbar,
  IonList,
  IonItem,
  IonLabel,
  IonToggle,
  IonIcon,
  IonSelect,
  IonSelectOption,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardTitle,
  IonAvatar,
  IonButton,
  IonItemDivider, 
  IonButtons, 
  IonBackButton,
  AlertController,
  ToastController
} from '@ionic/angular/standalone';
import { addIcons } from 'ionicons';
import {
  personOutline,
  notificationsOutline,
  settingsOutline,
  languageOutline,
  helpCircleOutline,
  logOutOutline,
  chevronForwardOutline
} from 'ionicons/icons';
import { Router } from '@angular/router';
import { ConfigService, Configuraciones, Usuario } from '../../services/config.service';

@Component({
  selector: 'app-conf',
  templateUrl: './conf.page.html',
  styleUrls: ['./conf.page.scss'],
  standalone: true,
  imports: [
    IonBackButton, 
    IonButtons,
    IonContent,
    IonHeader,
    IonTitle,
    IonToolbar,
    CommonModule,
    FormsModule,
    IonList,
    IonItem,
    IonLabel,
    IonToggle,
    IonIcon,
    IonSelect,
    IonSelectOption,
    IonCard,
    IonCardContent,
    IonCardHeader,
    IonCardTitle,
    IonAvatar,
    IonButton,
    IonItemDivider
  ]
})
export class ConfPage implements OnInit {
  // Datos del usuario
  usuario: Usuario;
  
  // Configuraciones
  configuraciones: Configuraciones;
  configuracionesOriginales: Configuraciones;
  
  // Opciones de idioma
  idiomas = [
    { valor: 'es', texto: 'Español' },
    { valor: 'en', texto: 'Inglés' },
    { valor: 'fr', texto: 'Francés' },
    { valor: 'de', texto: 'Alemán' }
  ];

  constructor(
    private router: Router,
    private configService: ConfigService,
    private alertController: AlertController,
    private toastController: ToastController
  ) {
    addIcons({
      personOutline,
      notificationsOutline,
      settingsOutline,
      languageOutline,
      helpCircleOutline,
      logOutOutline,
      chevronForwardOutline
    });
    
    // Inicializar con valores por defecto
    this.usuario = this.configService.usuarioActual;
    this.configuraciones = this.configService.configuracionesActuales;
    this.configuracionesOriginales = JSON.parse(JSON.stringify(this.configuraciones));
  }

  ngOnInit() {
    // Suscribirnos a los cambios en las configuraciones
    this.configService.configuraciones$.subscribe(config => {
      this.configuraciones = config;
      this.configuracionesOriginales = JSON.parse(JSON.stringify(config));
    });
    
    // Suscribirnos a los cambios en el usuario
    this.configService.usuario$.subscribe(user => {
      if (user) {
        this.usuario = user;
      }
    });
  }

  async guardarCambios() {
    try {
      // Guardar configuraciones usando el servicio
      this.configService.guardarConfiguraciones(this.configuraciones).subscribe(
        () => {
          this.configuracionesOriginales = JSON.parse(JSON.stringify(this.configuraciones));
          this.mostrarToast('Configuraciones guardadas correctamente');
        },
        error => {
          console.error('Error al guardar configuraciones:', error);
          this.mostrarToast('Error al guardar configuraciones', 'danger');
        }
      );
    } catch (error) {
      console.error('Error al guardar configuraciones:', error);
      this.mostrarToast('Error al guardar configuraciones', 'danger');
    }
  }

  async cerrarSesion() {
    // Verificar si hay cambios sin guardar
    if (this.hayCambiosSinGuardar()) {
      const alert = await this.alertController.create({
        header: 'Cambios sin guardar',
        message: '¿Desea guardar los cambios antes de cerrar sesión?',
        buttons: [
          {
            text: 'Cancelar',
            role: 'cancel'
          },
          {
            text: 'Salir sin guardar',
            handler: () => {
              this.logout();
            }
          },
          {
            text: 'Guardar y salir',
            handler: () => {
              this.guardarCambios();
              this.logout();
            }
          }
        ]
      });
      await alert.present();
    } else {
      this.logout();
    }
  }

  logout() {
    // Usar el servicio para cerrar sesión
    this.configService.cerrarSesion().subscribe(() => {
      this.router.navigate(['/login']);
    });
  }

  editarPerfil() {
    // Navegar a la página de edición de perfil
    this.router.navigate(['/editar-perfil']);
  }

  hayCambiosSinGuardar(): boolean {
    return JSON.stringify(this.configuraciones) !== JSON.stringify(this.configuracionesOriginales);
  }

  async mostrarToast(mensaje: string, color: string = 'success') {
    const toast = await this.toastController.create({
      message: mensaje,
      duration: 2000,
      color: color,
      position: 'bottom'
    });
    toast.present();
  }
}

================
File: src/app/pages/friends/friends.page.html
================
<div class="ion-page">
  <ion-header [translucent]="true">
    <ion-toolbar>
      <ion-buttons slot="start">
        <ion-menu-button></ion-menu-button>
      </ion-buttons>
      <ion-title>Friends</ion-title>
    </ion-toolbar>
  </ion-header>

  <ion-content [fullscreen]="true">
    <ion-header collapse="condense">
      <ion-toolbar>
        <ion-title size="large">Friends</ion-title>
      </ion-toolbar>
    </ion-header>

    <div class="add-friend-form" *ngIf="showAddFriendForm">
      <ion-card>
        <ion-card-header>
          <ion-card-title>Añadir nuevo amigo</ion-card-title>
        </ion-card-header>
        <ion-card-content>
          <ion-item>
            <ion-label position="floating">Nombre</ion-label>
            <ion-input [(ngModel)]="newFriend.name" placeholder="Introduce el nombre"></ion-input>
          </ion-item>
          <ion-item>
            <ion-label position="floating">Avatar URL (opcional)</ion-label>
            <ion-input [(ngModel)]="newFriend.avatar" placeholder="URL de la imagen"></ion-input>
          </ion-item>
          <div class="avatar-preview" *ngIf="newFriend.avatar">
            <ion-avatar>
              <img [src]="newFriend.avatar" (error)="handleImageError()">
            </ion-avatar>
          </div>
          <div class="button-group">
            <ion-button fill="outline" (click)="cancelAddFriend()">Cancelar</ion-button>
            <ion-button (click)="addFriend()" [disabled]="!newFriend.name">Añadir</ion-button>
          </div>
        </ion-card-content>
      </ion-card>
    </div>

    <div class="friends-container" *ngIf="!showAddFriendForm">      
      <div class="empty-state" *ngIf="friends.length === 0">
        <ion-icon name="people-outline"></ion-icon>
        <h3>No tienes amigos en tu lista</h3>
        <p>Pulsa en el botón + para añadir amigos</p>
      </div>
      
      <ion-list *ngIf="friends.length > 0" class="friend-list">
        <ion-item-sliding *ngFor="let friend of friends">
          <ion-item (click)="openChat(friend.id)" class="friend-item">
            <ion-avatar slot="start">
              <img [src]="friend.avatar" />
            </ion-avatar>
            <ion-label>
              <h2>{{ friend.name }}</h2>
            </ion-label>
            <ion-icon name="chatbubble-outline" slot="end"></ion-icon>
          </ion-item>
          
          <ion-item-options side="end">
            <ion-item-option color="danger" (click)="removeFriend(friend)">
              <ion-icon slot="icon-only" name="trash-outline"></ion-icon>
            </ion-item-option>
          </ion-item-options>
        </ion-item-sliding>
      </ion-list>
    </div>

    <ion-fab vertical="bottom" horizontal="end" slot="fixed">
      <ion-fab-button (click)="showAddFriendForm = true">
        <ion-icon name="person-add"></ion-icon>
      </ion-fab-button>
    </ion-fab>
  </ion-content>
</div>

================
File: src/app/pages/friends/friends.page.scss
================
.empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 50px 20px;
    text-align: center;
    
    ion-icon {
      font-size: 64px;
      color: var(--ion-color-medium);
      margin-bottom: 20px;
    }
    
    h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 500;
      color: var(--ion-color-dark);
    }
    
    p {
      margin: 10px 0 0;
      font-size: 14px;
      color: var(--ion-color-medium);
    }
  }
  
  .add-friend-form {
    padding: 10px;
    
    .avatar-preview {
      display: flex;
      justify-content: center;
      padding: 20px 0;
      
      ion-avatar {
        width: 100px;
        height: 100px;
      }
    }
    
    .button-group {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
  }
  
  .friends-container {
    padding: 16px;
    
    .section-title {
      margin-bottom: 16px;
      font-size: 24px;
      font-weight: 600;
      color: var(--ion-color-dark);
      padding-left: 5px;
    }
  }
  
  .friend-list {
    background: transparent;
    
    ion-item-sliding {
      margin-bottom: 10px;
      --border-radius: 10px;
      overflow: hidden;
    }
    
    .friend-item {
      --padding-start: 12px;
      --padding-end: 12px;
      --padding-top: 8px;
      --padding-bottom: 8px;
      --border-radius: 10px;
      --background: var(--ion-color-light);
      
      ion-avatar {
        width: 50px;
        height: 50px;
        border: 2px solid var(--ion-color-primary);
      }
      
      h2 {
        font-size: 16px;
        font-weight: 500;
      }
    }
  }
  
  // Estilos para el botón flotante
  ion-fab {
    margin-bottom: 16px;
    margin-right: 16px;
  }

================
File: src/app/pages/friends/friends.page.spec.ts
================
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { FriendsPage } from './friends.page';

describe('SearchPage', () => {
  let component: FriendsPage;
  let fixture: ComponentFixture<FriendsPage>;

  beforeEach(() => {
    fixture = TestBed.createComponent(FriendsPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/pages/friends/friends.page.ts
================
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Router } from '@angular/router';
import {
  IonHeader,
  IonToolbar,
  IonTitle,
  IonContent,
  IonList,
  IonItem,
  IonAvatar,
  IonLabel,
  IonButtons,
  IonMenuButton,
  IonButton,
  IonIcon,
  IonCard,
  IonCardHeader,
  IonCardTitle,
  IonCardContent,
  IonInput,
  IonItemSliding,
  IonItemOptions,
  IonItemOption,
  IonFab,
  IonFabButton,
  AlertController
} from '@ionic/angular/standalone';
import { addIcons } from 'ionicons';
import { menuOutline, personAdd, peopleOutline, trashOutline, chatbubbleOutline } from 'ionicons/icons';

interface Friend {
  id: number;
  name: string;
  avatar: string;
}

@Component({
  selector: 'app-friends',
  templateUrl: './friends.page.html',
  styleUrls: ['./friends.page.scss'],
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    IonHeader,
    IonToolbar,
    IonTitle,
    IonContent,
    IonList,
    IonItem,
    IonAvatar,
    IonLabel,
    IonButtons,
    IonMenuButton,
    IonButton,
    IonIcon,
    IonCard,
    IonCardHeader,
    IonCardTitle,
    IonCardContent,
    IonInput,
    IonItemSliding,
    IonItemOptions,
    IonItemOption,
    IonFab,
    IonFabButton
  ],
})
export class FriendsPage implements OnInit {
  showAddFriendForm = false;
  friends: Friend[] = [
    {
      id: 1,
      name: 'Juan Pérez',
      avatar: 'https://randomuser.me/api/portraits/men/1.jpg',
    },
    {
      id: 2,
      name: 'Ana López',
      avatar: 'https://randomuser.me/api/portraits/women/1.jpg',
    },
    {
      id: 3,
      name: 'Carlos García',
      avatar: 'https://randomuser.me/api/portraits/men/2.jpg',
    },
    {
      id: 4,
      name: 'Laura Martín',
      avatar: 'https://randomuser.me/api/portraits/women/2.jpg',
    },
  ];

  newFriend: Friend = {
    id: 0,
    name: '',
    avatar: ''
  };

  constructor(
    private router: Router,
    private alertController: AlertController
  ) {
    addIcons({
      menuOutline,
      personAdd,
      peopleOutline,
      trashOutline,
      chatbubbleOutline
    });
  }

  ngOnInit() {
    const savedFriends = localStorage.getItem('friendsList');
    if (savedFriends) {
      try {
        this.friends = JSON.parse(savedFriends);
      } catch (error) {
        console.error('Error al cargar amigos:', error);
      }
    }
  }

  openChat(friendId: number) {
    this.router.navigate(['/chat', friendId]);
  }

  cancelAddFriend() {
    this.showAddFriendForm = false;
    this.resetNewFriend();
  }

  resetNewFriend() {
    this.newFriend = {
      id: 0,
      name: '',
      avatar: ''
    };
  }

  handleImageError() {
    this.newFriend.avatar = 'https://randomuser.me/api/portraits/lego/1.jpg';
  }

  addFriend() {
    if (!this.newFriend.name.trim()) {
      alert('Por favor, introduce un nombre para el amigo');
      return;
    }
    const maxId = Math.max(...this.friends.map(f => f.id), 0);
    this.newFriend.id = maxId + 1;
    if (!this.newFriend.avatar) {
      const gender = Math.random() > 0.5 ? 'men' : 'women';
      const randomNum = Math.floor(Math.random() * 99) + 1;
      this.newFriend.avatar = `https://randomuser.me/api/portraits/${gender}/${randomNum}.jpg`;
    }
    this.friends.push({...this.newFriend});
    localStorage.setItem('friendsList', JSON.stringify(this.friends));
    alert(`${this.newFriend.name} ha sido añadido a tu lista de amigos`);
    this.showAddFriendForm = false;
    this.resetNewFriend();
  }

  async removeFriend(friend: Friend) {
    const alert = await this.alertController.create({
      header: 'Eliminar amigo',
      message: `¿Estás seguro de que quieres eliminar a ${friend.name} de tu lista de amigos?`,
      buttons: [
        {
          text: 'Cancelar',
          role: 'cancel'
        },
        {
          text: 'Eliminar',
          handler: () => {
            this.friends = this.friends.filter(f => f.id !== friend.id);
            localStorage.setItem('friendsList', JSON.stringify(this.friends));
          }
        }
      ]
    });

    await alert.present();
  }
}

================
File: src/app/pages/home/home.page.html
================
<ion-header>
  <ion-toolbar color="light">
    <div class="flex items-center justify-between w-full px-4 py-2">
      <ion-buttons slot="start">
        <ion-menu-button menu="main-menu"></ion-menu-button>
      </ion-buttons>
      <div class="flex-1 mx-4">
        <ion-searchbar placeholder="Buscar música..." 
                      [(ngModel)]="searchTerm"
                      (ionInput)="searchMusic($event)"
                      (ionClear)="clearSearch()"
                      class="w-full"></ion-searchbar>
      </div>
    </div>
  </ion-toolbar>
</ion-header>

<ion-content color="light" class="ion-padding-bottom">
  <div *ngIf="isLoading" class="ion-padding ion-text-center">
    <ion-spinner name="circular"></ion-spinner>
    <p>Cargando música...</p>
  </div>

  <div *ngIf="trendingTracks.length > 0" class="ion-padding-horizontal ion-padding-top">
    <h2 class="ion-text-white">Top 10 Trending</h2>

    <div class="tracks-carousel">
      <div class="scroll-container">
        <div *ngFor="let track of trendingTracks" class="track-card" [class.active]="currentTrack?.id === track.id"
          (click)="togglePlayPause(track)">
          <div class="track-artwork">
            <img [src]="track.artwork?.['480x480'] || 'assets/default.jpg'" alt="{{ track.title }}">
            <div class="play-overlay">
              <ion-icon
                [name]="(currentTrack?.id === track.id && isPlaying) ? 'pause-outline' : 'play-outline'"></ion-icon>
            </div>
          </div>
          <div class="track-info">
            <h4 class="ion-text-wrap ion-text-white">{{ track.title }}</h4>
            <p class="ion-text-wrap ion-text-color-medium">{{ track.user.name }}</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="ion-padding-horizontal ion-padding-top">
    <h2 class="ion-text-white">Playlists destacadas</h2>

    <div *ngFor="let playlist of playlists" class="playlist-container ion-margin-bottom">
      <ion-card color="medium" (click)="togglePlaylistExpansion(playlist)">
        <div class="playlist-header ion-padding">
          <div class="playlist-artwork">
            <img [src]="playlist.artwork?.['480x480'] || 'assets/default.jpg'" alt="{{ playlist.playlist_name }}">
          </div>
          <div class="playlist-info">
            <h3 class="ion-text-wrap ion-text-uppercase ion-text-white">{{ playlist.playlist_name }}</h3>
            <p class="ion-text-sm ion-text-color-light">Por: {{ playlist.user.name || 'Usuario desconocido' }}</p>
            <p *ngIf="playlist.description" class="ion-text-sm ion-text-color-light description">{{ playlist.description }}</p>
            <p class="ion-text-sm ion-text-color-light">
              {{ playlist.track_count || (playlist.playlist_contents ? playlist.playlist_contents.length : 0) }}
              canciones
            </p>
          </div>
          <div class="expand-icon">
            <ion-icon name="chevron-down-outline" [class.rotated]="playlist.expanded"></ion-icon>
          </div>
        </div>
      </ion-card>

      <div *ngIf="playlist.expanded" class="playlist-tracks">
        <ion-list>
          <ion-item *ngFor="let item of playlist.playlist_contents" lines="none" class="track-item" color="light"
            (click)="playTrack({
              id: item.track_id || item.id,
              title: item.title || 'Canción ' + (item.track_id || item.id),
              user: { name: item.user?.name || 'Artista desconocido' },
              artwork: item.artwork || playlist.artwork
            })">
            <ion-thumbnail slot="start">
              <img [src]="item.artwork?.['150x150'] || playlist.artwork?.['150x150'] || 'assets/default.jpg'">
            </ion-thumbnail>
            <ion-label>
              <h3 class="ion-text-wrap ion-text-white">{{ item.title || 'Canción ' + (item.track_id || item.id) }}</h3>
              <p class="ion-text-sm ion-text-color-medium">{{ item.user?.name || 'Artista desconocido' }}</p>
            </ion-label>
            <div slot="end" class="track-status">
              <ion-icon *ngIf="currentTrack?.id === (item.track_id || item.id) && isPlaying"
                name="musical-notes-outline" color="primary"></ion-icon>
            </div>
          </ion-item>
        </ion-list>
      </div>
    </div>
  </div>

  <ion-infinite-scroll (ionInfinite)="loadMore($event)">
    <ion-infinite-scroll-content loadingSpinner="bubbles" loadingText="Cargando más música...">
    </ion-infinite-scroll-content>
  </ion-infinite-scroll>
</ion-content>

<div *ngIf="showSearchResults" class="search-results-container" [class.with-player]="currentTrack">
  <div class="search-results-header">
    <h3 class="ion-text-white">Resultados para "{{ searchTerm }}"</h3>
    <ion-button fill="clear" color="light" (click)="clearSearch()">
      <ion-icon name="close-outline" slot="icon-only"></ion-icon>
    </ion-button>
  </div>
  
  <div class="search-results-content">
    <ion-list *ngIf="searchResults.length > 0; else noResults">
      <ion-item *ngFor="let item of searchResults" (click)="playSearchResult(item)">
        <ion-thumbnail slot="start">
          <img [src]="item.artwork?.['150x150'] || 'assets/default.jpg'" alt="Artwork">
        </ion-thumbnail>
        <ion-label>
          <h2>{{ item.title }}</h2>
          <p>{{ item.user?.name || 'Artista Desconocido' }}</p>
          <p *ngIf="item.type === 'track'">Track · {{ item.playCount || 0 }} plays</p>
          <p *ngIf="item.type === 'playlist'">Playlist · {{ item.trackCount || 0 }} tracks</p>
        </ion-label>
        <ion-icon slot="end" name="play-outline"></ion-icon>
      </ion-item>
    </ion-list>
    <ng-template #noResults>
      <div class="no-results ion-padding ion-text-center" *ngIf="!isSearching">
        <ion-icon name="search-outline" class="large-icon"></ion-icon>
        <p>No se encontraron resultados para "{{ searchTerm }}"</p>
      </div>
      <div class="loading-results ion-padding ion-text-center" *ngIf="isSearching">
        <ion-spinner></ion-spinner>
        <p>Buscando...</p>
      </div>
    </ng-template>
  </div>
</div>

<ion-footer *ngIf="currentTrack" class="ion-no-border">
  <!-- Mini Reproductor (compacto) -->
  <div class="progress-bar-container">
    <ion-progress-bar [value]="getDurationPercentage() / 100"></ion-progress-bar>
  </div>
  
  <ion-toolbar color="medium">
    <ion-item lines="none" color="medium" (click)="togglePlayer()">
      <ion-thumbnail slot="start">
        <img [src]="currentTrack.artwork?.['150x150'] || 'assets/default.jpg'">
      </ion-thumbnail>
      <ion-label>
        <h3 class="ion-text-wrap ion-text-white">{{ currentTrack.title || 'Canción ' + currentTrack.id }}</h3>
        <p class="ion-text-sm ion-text-color-light">{{ currentTrack.user.name || 'Artista desconocido' }}</p>
      </ion-label>
      <ion-buttons slot="end">
        <ion-button fill="clear" color="light" (click)="previousTrack(); $event.stopPropagation()">
          <ion-icon name="play-skip-back-outline" slot="icon-only"></ion-icon>
        </ion-button>
        <ion-button fill="clear" color="light" (click)="isPlaying ? pauseTrack() : playTrack(currentTrack); $event.stopPropagation()">
          <ion-icon [name]="isPlaying ? 'pause-outline' : 'play-outline'" slot="icon-only"></ion-icon>
        </ion-button>
        <ion-button fill="clear" color="light" (click)="nextTrack(); $event.stopPropagation()">
          <ion-icon name="play-skip-forward-outline" slot="icon-only"></ion-icon>
        </ion-button>
      </ion-buttons>
    </ion-item>
  </ion-toolbar>
  
  <!-- Reproductor expandido -->
  <div class="expanded-player" *ngIf="isPlayerExpanded" color="medium">
    <div class="player-content ion-padding">
      <div class="player-header">
        <ion-button fill="clear" color="light" (click)="togglePlayer()">
          <ion-icon name="chevron-down-outline" slot="icon-only"></ion-icon>
        </ion-button>
      </div>
      
      <div class="artwork-container">
        <img [src]="currentTrack.artwork?.['480x480'] || 'assets/default.jpg'" class="large-artwork">
      </div>
      
      <div class="track-info ion-text-center ion-padding">
        <h2 class="ion-text-white">{{ currentTrack.title }}</h2>
        <p class="ion-text-color-light">{{ currentTrack.user.name }}</p>
      </div>
      
      <div class="player-controls">
        <div class="track-progress">
          <span class="current-time">{{ getFormattedTime(currentTime) }}</span>
          <ion-range #trackSeeker
            [min]="0"
            [max]="duration"
            [value]="currentTime"
            (ionChange)="onSeek($event)"
            color="light"
            class="track-seeker">
          </ion-range>
          <span class="total-time">{{ getFormattedTime(duration) }}</span>
        </div>
        
        <div class="player-buttons ion-text-center">
          <ion-button fill="clear" color="light" size="large" (click)="previousTrack()">
            <ion-icon name="play-skip-back-outline" slot="icon-only"></ion-icon>
          </ion-button>
          <ion-button fill="clear" color="light" size="large" (click)="isPlaying ? pauseTrack() : playTrack(currentTrack)">
            <ion-icon [name]="isPlaying ? 'pause-outline' : 'play-outline'" slot="icon-only" class="play-button"></ion-icon>
          </ion-button>
          <ion-button fill="clear" color="light" size="large" (click)="nextTrack()">
            <ion-icon name="play-skip-forward-outline" slot="icon-only"></ion-icon>
          </ion-button>
        </div>
      </div>
    </div>
  </div>
</ion-footer>

================
File: src/app/pages/home/home.page.scss
================
// Estilos para el carrusel de tracks
.tracks-carousel {
  width: 100%;
  margin-bottom: 16px;
  
  .scroll-container {
    display: flex;
    overflow-x: auto;
    scroll-snap-type: x mandatory;
    scrollbar-width: none; // Firefox
    -ms-overflow-style: none; // IE & Edge
    padding: 10px 0;
    
    &::-webkit-scrollbar {
      display: none; // Chrome, Safari
    }
  }
  
  .track-card {
    scroll-snap-align: start;
    flex: 0 0 auto;
    width: 150px;
    margin-right: 12px;
    border-radius: 12px;
    overflow: hidden;
    transition: transform 0.2s;
    position: relative;
    
    &.active {
      transform: scale(1.03);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    &:active {
      transform: scale(0.98);
    }
    
    .track-artwork {
      position: relative;
      width: 100%;
      height: 150px;
      
      img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      .play-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.2s;
        
        ion-icon {
          font-size: 32px;
          color: white;
        }
      }
      
      &:hover .play-overlay {
        opacity: 1;
      }
    }
    
    .track-info {
      padding: 8px;
      background: var(--ion-color-medium);
      
      h4 {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
      }
      
      p {
        margin: 4px 0 0;
        font-size: 12px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
    }
  }
}

// Estilos para las playlists
.playlist-container {
  .playlist-header {
    display: flex;
    align-items: flex-start;
    position: relative;
    
    .playlist-artwork {
      width: 100px;
      height: 100px;
      flex-shrink: 0;
      margin-right: 12px;
      border-radius: 6px;
      overflow: hidden;
      
      img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
    }
    
    .playlist-info {
      flex: 1;
      
      h3 {
        margin: 0 0 4px;
        font-size: 18px;
        font-weight: 700;
      }
      
      p {
        margin: 2px 0;
        
        &.description {
          overflow: hidden;
          text-overflow: ellipsis;
          display: -webkit-box;
          -webkit-line-clamp: 2;
          -webkit-box-orient: vertical;
        }
      }
    }
    
    .expand-icon {
      position: absolute;
      right: 12px;
      top: 12px;
      
      ion-icon {
        font-size: 24px;
        transition: transform 0.3s ease;
        
        &.rotated {
          transform: rotate(180deg);
        }
      }
    }
  }
  
  .playlist-tracks {
    border-radius: 0 0 16px 16px;
    overflow: hidden;
    margin-top: -16px;
    
    .track-item {
      --padding-start: 8px;
      --padding-end: 8px;
      --inner-padding-end: 8px;
      margin-bottom: 2px;
      
      &:last-child {
        margin-bottom: 0;
      }
      
      ion-thumbnail {
        width: 50px;
        height: 50px;
        --border-radius: 4px;
      }
      
      .track-status {
        display: flex;
        align-items: center;
        
        ion-icon {
          font-size: 24px;
          animation: pulse 1.5s infinite;
        }
      }
    }
  }
}

// Animación para el icono de reproducción
@keyframes pulse {
  0% {
    opacity: 0.6;
    transform: scale(0.9);
  }
  50% {
    opacity: 1;
    transform: scale(1.1);
  }
  100% {
    opacity: 0.6;
    transform: scale(0.9);
  }
}

// Ajustes generales
ion-content {
  --padding-bottom: 72px; // Espacio para el reproductor
}

// Estilo para las cards expandibles
ion-card {
  margin: 8px 0;
  border-radius: 12px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  cursor: pointer;
  transition: transform 0.2s;
  
  &:active {
    transform: scale(0.98);
  }
}

// Eliminar bordes de las listas
ion-list {
  background: transparent;
  padding: 0;
}

// Estilo para el reproductor
ion-footer {
  ion-toolbar {
    --border-width: 0;
    --background: var(--ion-color-medium);
    
    ion-item {
      --padding-start: 8px;
      --padding-end: 8px;
      --min-height: 64px;
      
      ion-buttons {
        margin-right: 0;
      }
    }
  }
}

.search-results-container {
  position: fixed;
  top: 56px; // Ajusta esto a la altura exacta de tu header
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--ion-color-light);
  z-index: 100;
  display: flex;
  flex-direction: column;
}

.search-results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
  background-color: var(--ion-color-medium);
  border-bottom: 1px solid var(--ion-color-medium-shade);
}

.search-results-content {
  flex: 1;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch; // Mejora el desplazamiento en iOS
}

ion-list {
  padding-bottom: 70px; // Espacio adicional para evitar que el reproductor oculte contenido
}

// Si tienes un reproductor en la parte inferior
.search-results-container.with-player {
  bottom: 56px; // Ajusta según la altura de tu player bar
}

/* Progreso de la canción en el mini reproductor */
.progress-bar-container {
  height: 3px;
  width: 100%;
}

/* Estilos para el reproductor expandido */
.expanded-player {
  background-color: var(--ion-color-medium);
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 100%;
  z-index: 999;
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}

.player-header {
  display: flex;
  justify-content: center;
  padding-top: 10px;
}

.player-content {
  display: flex;
  flex-direction: column;
  height: 100%;
  padding-bottom: 40px;
}

.artwork-container {
  display: flex;
  justify-content: center;
  margin: 20px 0;
}

.large-artwork {
  width: 240px;
  height: 240px;
  object-fit: cover;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.track-info {
  margin-bottom: 20px;
}

.track-progress {
  display: flex;
  align-items: center;
  padding: 0 15px;
}

.current-time, .total-time {
  font-size: 12px;
  color: var(--ion-color-light);
}

.track-seeker {
  --bar-height: 3px;
  --knob-size: 15px;
  margin: 0 10px;
}

.player-buttons {
  margin: 15px 0;
}

.play-button {
  font-size: 36px;
}

.volume-control {
  display: flex;
  align-items: center;
  margin-top: 20px;
}

.volume-icon {
  margin-right: 10px;
  color: var(--ion-color-light);
}

/* Ajustes para cuando existe el reproductor */
.search-results-container.with-player {
  bottom: 56px; /* Altura del mini-reproductor */
}

/* Estilos para el reproductor mini */
ion-footer ion-thumbnail {
  width: 48px;
  height: 48px;
  --border-radius: 4px;
}

================
File: src/app/pages/home/home.page.spec.ts
================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HomePage } from './home.page';

describe('HomePage', () => {
  let component: HomePage;
  let fixture: ComponentFixture<HomePage>;

  beforeEach(async () => {
    fixture = TestBed.createComponent(HomePage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/pages/home/home.page.ts
================
import {
  Component,
  OnInit,
  CUSTOM_ELEMENTS_SCHEMA,
  ViewChild,
  OnDestroy,
  ElementRef,
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import {
  IonContent,
  IonHeader,
  IonToolbar,
  IonItem,
  IonButton,
  IonThumbnail,
  IonIcon,
  IonCard,
  IonList,
  IonLabel,
  IonFooter,
  IonSpinner,
  IonInfiniteScroll,
  IonInfiniteScrollContent,
  InfiniteScrollCustomEvent,
  IonSearchbar,
  IonButtons,
  IonMenuButton,
  IonRange,
  RangeCustomEvent,
  IonProgressBar,
} from '@ionic/angular/standalone';
import { AudiusFacade } from 'src/app/services/facades/audius.facade';
import { addIcons } from 'ionicons';
import {
  playOutline,
  pauseOutline,
  musicalNotesOutline,
  stopOutline,
  chevronDownOutline,
  personCircleOutline,
  closeOutline,
  searchOutline,
  playSkipForwardOutline,
  playSkipBackOutline,
  menuOutline,
  volumeHighOutline,
} from 'ionicons/icons';
import { SplashScreen } from '@capacitor/splash-screen';
import { Subject, takeUntil, finalize, forkJoin, of, from } from 'rxjs';
import {
  catchError,
  map,
  switchMap,
  tap,
  toArray,
  concatMap,
  filter,
} from 'rxjs/operators';

interface Track {
  id: string;
  title: string;
  user: {
    name: string;
  };
  artwork?: {
    [key: string]: string;
  };
}

interface Playlist {
  id: string;
  playlist_name: string;
  playlist_contents: any[];
  user: {
    name: string;
  };
  artwork?: {
    [key: string]: string;
  };
  description?: string;
  track_count?: number;
  expanded?: boolean;
  isLoading?: boolean;
}

@Component({
  selector: 'app-home',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    IonContent,
    IonHeader,
    IonToolbar,
    IonItem,
    IonButton,
    IonThumbnail,
    IonIcon,
    IonCard,
    IonList,
    IonLabel,
    IonFooter,
    IonSpinner,
    IonInfiniteScroll,
    IonInfiniteScrollContent,
    IonSearchbar,
    IonButtons,
    IonMenuButton,
    IonRange,
    IonProgressBar,
  ],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  templateUrl: './home.page.html',
  styleUrls: ['./home.page.scss'],
})
export class HomePage implements OnInit, OnDestroy {
  @ViewChild(IonInfiniteScroll) infiniteScroll!: IonInfiniteScroll;
  @ViewChild('trackSeeker') trackSeeker?: ElementRef<HTMLIonRangeElement>;

  private destroy$ = new Subject<void>();
  searchTerm: string = '';
  searchResults: any[] = [];
  isSearching: boolean = false;
  showSearchResults: boolean = false;
  trendingTracks: Track[] = [];
  playlists: Playlist[] = [];
  currentTrack: Track | null = null;
  isPlaying: boolean = false;
  isLoading: boolean = true;
  private _searchTimeout: any;

  currentTime: number = 0;
  duration: number = 0;
  currentPlaylist: any[] | null = null;
  currentTrackIndex: number = -1;
  isPlayerExpanded: boolean = false;

  private tracksCache: Map<string, any> = new Map();

  playlistsOffset: number = 0;
  limit: number = 10;
  hasMorePlaylists: boolean = true;
  allPlaylists: Playlist[] = [];

  constructor(private audiusFacade: AudiusFacade) {
    addIcons({
      personCircleOutline,
      chevronDownOutline,
      musicalNotesOutline,
      closeOutline,
      playOutline,
      searchOutline,
      stopOutline,
      pauseOutline,
      menuOutline,
      playSkipForwardOutline,
      playSkipBackOutline,
    });
  }

  ngOnInit() {
    SplashScreen.show({
      autoHide: false,
    });

    this.audiusFacade
      .isPlaying()
      .pipe(takeUntil(this.destroy$))
      .subscribe((isPlaying) => {
        this.isPlaying = isPlaying;
      });

    this.audiusFacade
      .getCurrentTime()
      .pipe(takeUntil(this.destroy$))
      .subscribe((time) => {
        this.currentTime = time;
      });

    this.audiusFacade
      .getDuration()
      .pipe(takeUntil(this.destroy$))
      .subscribe((duration) => {
        this.duration = duration;
      });

    this.audiusFacade
      .getCurrentPlaylist()
      .pipe(takeUntil(this.destroy$))
      .subscribe((playlist) => {
        this.currentPlaylist = playlist;
      });

    this.audiusFacade
      .getCurrentTrackIndex()
      .pipe(takeUntil(this.destroy$))
      .subscribe((index) => {
        this.currentTrackIndex = index;
      });

    this.audiusFacade
      .getCurrentTrackId()
      .pipe(takeUntil(this.destroy$))
      .subscribe((trackId) => {
        if (!trackId) {
          this.currentTrack = null;
          return;
        }

        const track = this.findTrackInData(trackId);

        if (track) {
          this.currentTrack = track;
          this.updateMediaSession();
          return;
        }

        this.audiusFacade
          .getTrackById(trackId)
          .pipe(
            catchError(() => of(null)),
            takeUntil(this.destroy$)
          )
          .subscribe((response) => {
            if (response?.data) {
              const trackData = response.data;

              this.tracksCache.set(trackId, trackData);

              this.currentTrack = {
                id: trackData.id,
                title: trackData.title,
                user: {
                  name: trackData.user?.name || 'Artista Desconocido',
                },
                artwork: trackData.artwork,
              };

              this.updateMediaSession();
            }
          });
      });

    forkJoin({
      tracks: this.audiusFacade
        .tracks()
        .pipe(catchError(() => of({ data: [] }))),
      playlists: this.audiusFacade
        .playlists()
        .pipe(catchError(() => of({ data: [] }))),
    })
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => {
          // La pantalla de splash se ocultará después de validar las playlists
        })
      )
      .subscribe({
        next: (results) => {
          // Procesamos los tracks primero
          if (results.tracks?.data) {
            this.trendingTracks = results.tracks.data.slice(0, 10);
            results.tracks.data.forEach((track: any) => {
              this.tracksCache.set(track.id, track);
            });
          }

          // Ahora procesamos y validamos las playlists
          if (results.playlists?.data) {
            const rawPlaylists = results.playlists.data.map(
              (playlist: Playlist) => ({
                ...playlist,
                expanded: false,
                isLoading: false,
              })
            );

            // Validamos las playlists (eliminando las inválidas)
            this.validateAllPlaylists(rawPlaylists);
          } else {
            this.isLoading = false;
            SplashScreen.hide();
          }
        },
        error: () => {
          this.isLoading = false;
          SplashScreen.hide();
        },
      });
  }

  private validateAllPlaylists(playlists: Playlist[]) {
    const validationTasks = playlists.map((playlist) =>
      this.validatePlaylist(playlist).pipe(catchError(() => of(null)))
    );

    forkJoin(validationTasks)
      .pipe(
        map((results) => results.filter((p) => p !== null) as Playlist[]),
        finalize(() => {
          this.isLoading = false;
          SplashScreen.hide();
        }),
        takeUntil(this.destroy$)
      )
      .subscribe((validPlaylists) => {
        this.allPlaylists = validPlaylists;
        this.playlists = this.allPlaylists.slice(0, this.limit);
        this.hasMorePlaylists = this.allPlaylists.length > this.limit;

        if (this.playlists.length > 0) {
          this.togglePlaylistExpansion(this.playlists[0]);
        }
      });
  }

  private validatePlaylist(playlist: Playlist) {
    if (!playlist.id) return of(null);

    return this.audiusFacade.playlistTracks(playlist.id).pipe(
      map((response) => {
        if (
          response?.data &&
          Array.isArray(response.data) &&
          response.data.length > 0
        ) {
          // Guardamos los tracks en caché
          response.data.forEach((track: any) => {
            if (track.id) {
              this.tracksCache.set(track.id, track);
            }
          });

          // Devolvemos la playlist con sus tracks
          return {
            ...playlist,
            playlist_contents: response.data,
            track_count: response.data.length,
          };
        }
        // Si no hay tracks, retornamos null para filtrarla
        return null;
      }),
      catchError((error) => {
        console.log(
          `Playlist ${playlist.id} - ${playlist.playlist_name} ignorada por error:`,
          error
        );
        return of(null);
      })
    );
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private findTrackInData(trackId: string): Track | null {
    if (this.tracksCache.has(trackId)) {
      const cachedTrack = this.tracksCache.get(trackId);
      return {
        id: cachedTrack.id,
        title: cachedTrack.title,
        user: { name: cachedTrack.user?.name || 'Artista Desconocido' },
        artwork: cachedTrack.artwork,
      };
    }

    const trendingTrack = this.trendingTracks.find((t) => t.id === trackId);
    if (trendingTrack) return trendingTrack;

    for (const playlist of this.playlists) {
      if (!playlist.playlist_contents) continue;

      const playlistTrack = playlist.playlist_contents.find(
        (item: any) =>
          (item.track_id === trackId || item.id === trackId) &&
          (item.title || item.id)
      );

      if (playlistTrack) {
        const track = {
          id: playlistTrack.track_id || playlistTrack.id,
          title:
            playlistTrack.title ||
            `Track ${playlistTrack.track_id || playlistTrack.id}`,
          user: { name: playlistTrack.user?.name || 'Artista Desconocido' },
          artwork: playlistTrack.artwork || playlist.artwork,
        };
        this.tracksCache.set(trackId, track);
        return track;
      }
    }

    return null;
  }

  togglePlaylistExpansion(playlist: Playlist) {
    if (playlist.expanded) {
      playlist.expanded = false;
      return;
    }

    if (playlist.playlist_contents?.length > 0) {
      playlist.expanded = true;
      return;
    }

    playlist.isLoading = true;

    this.loadPlaylistTracksEfficiently(playlist, true)
      .pipe(
        finalize(() => {
          playlist.isLoading = false;
        }),
        takeUntil(this.destroy$)
      )
      .subscribe((tracks) => {
        playlist.expanded = tracks && tracks.length > 0;
      });
  }

  private loadPlaylistTracksEfficiently(
    playlist: Playlist,
    forceReload: boolean = false
  ) {
    if (!playlist.id) return of(null);

    if (
      !forceReload &&
      playlist.playlist_contents?.length &&
      !playlist.isLoading
    ) {
      return of(playlist.playlist_contents);
    }

    console.log('Cargando tracks de la playlist:', playlist.id);

    return this.audiusFacade.playlistTracks(playlist.id).pipe(
      map((response) => {
        if (response?.data) {
          playlist.playlist_contents = response.data;
          playlist.track_count = response.data.length;

          response.data.forEach((track: any) => {
            if (track.id) {
              this.tracksCache.set(track.id, track);
            }
          });

          return response.data;
        }
        return [];
      }),
      catchError((error) => {
        console.error('Error al cargar los tracks:', error);
        return of([]);
      })
    );
  }

  playTrack(track: Track, playlistTracks?: any[]) {
    if (!track?.id) {
      console.error('Error: track es inválido. No se puede reproducir.');
      return;
    }
  
    const trackId = track.id;
    
    // Si se están reproduciendo tracks de una playlist, usar esa playlist
    if (playlistTracks && playlistTracks.length) {
      this.audiusFacade.play(trackId, playlistTracks);
    } else if (this.currentPlaylist) {
      // Mantener la playlist actual si existe
      this.audiusFacade.play(trackId, this.currentPlaylist);
    } else {
      // Si no hay playlist, crear una con solo este track
      this.audiusFacade.play(trackId, [track]);
    }
  }

  pauseTrack() {
    this.audiusFacade.pause();
  }

  stopTrack() {
    this.audiusFacade.stop();
  }

  togglePlayPause(track: Track) {
    if (this.currentTrack?.id === track.id) {
      this.isPlaying ? this.pauseTrack() : this.audiusFacade.play(track.id);
    } else {
      this.playTrack(track);
    }
  }

  togglePlayer() {
    this.isPlayerExpanded = !this.isPlayerExpanded;
  }

  nextTrack() {
    this.audiusFacade.next();
  }

  previousTrack() {
    this.audiusFacade.previous();
  }

  seekTo(position: number) {
    this.audiusFacade.seekTo(position);
  }

  onSeek(event: Event) {
    const rangeEvent = event as RangeCustomEvent;
    const position = rangeEvent.detail.value as number;
    this.seekTo(position);
  }

  updateMediaSession() {
    if (!('mediaSession' in navigator) || !this.currentTrack) return;

    navigator.mediaSession.metadata = new MediaMetadata({
      title: this.currentTrack.title || 'Unknown Title',
      artist: this.currentTrack.user?.name || 'Unknown Artist',
      album: 'Audius',
      artwork: [
        {
          src: this.currentTrack.artwork?.['1000x1000'] || 'assets/default.jpg',
          sizes: '1000x1000',
          type: 'image/jpeg',
        },
      ],
    });

    // Mejorar los handlers para que usen nuestras nuevas implementaciones
    navigator.mediaSession.setActionHandler('play', () => {
      if (this.currentTrack) {
        this.audiusFacade.play(this.currentTrack.id);
      }
    });

    navigator.mediaSession.setActionHandler('pause', () => {
      this.pauseTrack();
    });

    navigator.mediaSession.setActionHandler('previoustrack', () => {
      this.previousTrack();
    });

    navigator.mediaSession.setActionHandler('nexttrack', () => {
      this.nextTrack();
    });
  }

  getFormattedTime(time: number): string {
    return this.audiusFacade.formatTime(time);
  }

  getDurationPercentage(): number {
    if (!this.duration) return 0;
    return (this.currentTime / this.duration) * 100;
  }

  loadMore(event: any) {
    if (!this.hasMorePlaylists) {
      (event as InfiniteScrollCustomEvent).target.complete();
      (event as InfiniteScrollCustomEvent).target.disabled = true;
      return;
    }

    this.playlistsOffset += this.limit;

    setTimeout(() => {
      const newPlaylists = this.allPlaylists.slice(
        this.playlistsOffset,
        this.playlistsOffset + this.limit
      );

      if (newPlaylists.length) {
        this.playlists = [...this.playlists, ...newPlaylists];

        this.hasMorePlaylists =
          this.playlistsOffset + this.limit < this.allPlaylists.length;
      } else {
        this.hasMorePlaylists = false;
      }

      (event as InfiniteScrollCustomEvent).target.complete();

      if (!this.hasMorePlaylists) {
        (event as InfiniteScrollCustomEvent).target.disabled = true;
      }
    }, 300);
  }

  searchMusic(event: any) {
    const query = event.target.value.trim();
    this.searchTerm = query;

    if (!query || query.length < 1) {
      this.searchResults = [];
      this.showSearchResults = false;
      return;
    }

    this.isSearching = true;
    this.showSearchResults = true;

    clearTimeout(this._searchTimeout);
    this._searchTimeout = setTimeout(() => {
      this.audiusFacade
        .search(query)
        .pipe(
          finalize(() => {
            this.isSearching = false;
          }),
          takeUntil(this.destroy$)
        )
        .subscribe((response) => {
          if (response?.data) {
            this.searchResults = response.data.map((track: any) => {
              if (track.id) {
                this.tracksCache.set(track.id, track);
              }

              return {
                type: 'track',
                id: track.id,
                title: track.title,
                user: track.user,
                artwork: track.artwork,
                playCount: track.play_count,
                duration: track.duration,
              };
            });
          } else {
            this.searchResults = [];
          }
        });
    }, 300);
  }

  clearSearch() {
    this.searchTerm = '';
    this.searchResults = [];
    this.showSearchResults = false;
  }

  playSearchResult(item: any) {
    if (item.type === 'track') {
      this.playTrack({
        id: item.id,
        title: item.title,
        user: item.user,
        artwork: item.artwork,
      });
    } else if (item.type === 'playlist') {
      const playlistInState = this.allPlaylists.find((p) => p.id === item.id);

      if (playlistInState?.playlist_contents?.length) {
        const firstTrack = playlistInState.playlist_contents[0];
        const trackId = firstTrack.track_id || firstTrack.id;
        if (trackId) {
          this.audiusFacade.play(trackId, playlistInState.playlist_contents);
        }
        return;
      }

      this.audiusFacade
        .getPlaylistById(item.id)
        .pipe(takeUntil(this.destroy$))
        .subscribe((response) => {
          const contents = response?.data?.playlist_contents;
          if (contents?.length) {
            const firstTrackId = contents[0].track_id || contents[0].id;
            if (firstTrackId) {
              this.audiusFacade.play(firstTrackId, contents);
            }
          }
        });
    }
  }
  playPlaylist(playlist: Playlist) {
    if (
      !playlist.playlist_contents ||
      playlist.playlist_contents.length === 0
    ) {
      console.log(
        `Cargando tracks para la playlist ${playlist.id} antes de reproducir`
      );
      this.loadPlaylistTracksEfficiently(playlist)
        .pipe(takeUntil(this.destroy$))
        .subscribe((tracks) => {
          if (tracks && tracks.length > 0) {
            console.log(`Tracks cargados: ${tracks.length}`);
            // Normalizar los tracks
            const normalizedTracks = tracks.map(
              (track: { track_id: any; id: any }) => ({
                ...track,
                id: track.track_id || track.id,
              })
            );

            const firstTrack = normalizedTracks[0];
            const trackId = firstTrack.id;
            if (trackId) {
              console.log(`Reproduciendo primer track: ${trackId}`);
              this.audiusFacade.play(trackId, normalizedTracks);
            }
          } else {
            console.warn('No se encontraron tracks en la playlist');
          }
        });
    } else {
      console.log(
        `Playlist ya cargada con ${playlist.playlist_contents.length} tracks`
      );
      // Normalizar los tracks
      const normalizedTracks = playlist.playlist_contents.map((track) => ({
        ...track,
        id: track.track_id || track.id,
      }));

      const firstTrack = normalizedTracks[0];
      const trackId = firstTrack.id;
      if (trackId) {
        console.log(`Reproduciendo primer track: ${trackId}`);
        this.audiusFacade.play(trackId, normalizedTracks);
      }
    }
  }

  trackFromPlaylist(playlist: Playlist, trackIndex: number) {
    if (
      !playlist.playlist_contents ||
      trackIndex >= playlist.playlist_contents.length
    ) {
      return;
    }

    const trackItem = playlist.playlist_contents[trackIndex];
    const trackId = trackItem.track_id || trackItem.id;

    if (trackId) {
      this.audiusFacade.play(trackId, playlist.playlist_contents);
    }
  }

  isCurrentlyPlaying(trackId: string): boolean {
    return this.currentTrack?.id === trackId && this.isPlaying;
  }

  getArtworkUrl(track: any, size: string = '480x480'): string {
    if (track?.artwork && track.artwork[size]) {
      return track.artwork[size];
    }
    return 'assets/default.jpg';
  }
}

================
File: src/app/pages/login/login.page.html
================
<ion-content class="bg-gradient-to-br from-ionic-primary to-ionic-tertiary">
  <div class="flex min-h-full items-center justify-center py-12 px-4">
    <div class="w-full max-w-md bg-ionic-light rounded-xl shadow-lg p-8">

      <div class="text-center mb-8">
        <ion-icon name="lock-closed" class="text-6xl text-ionic-primary"></ion-icon>
        <h2 class="mt-3 text-2xl font-bold text-ionic-dark">Iniciar Sesión</h2>
        <p class="mt-2 text-sm text-ionic-medium">Ingresa tus credenciales para acceder</p>
      </div>

      <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
        <div class="mb-4">
          <label for="username" class="block text-sm font-medium text-ionic-medium mb-1">Username</label>
          <div class="relative">
            <ion-icon name="person" class="absolute left-3 top-3 text-ionic-medium"></ion-icon>
            <input 
              type="text" 
              id="username" 
              formControlName="username" 
              class="pl-10 w-full py-2 px-3 border border-ionic-medium rounded-lg focus:ring-2 focus:ring-ionic-primary focus:border-ionic-primary" 
              placeholder="Tu nombre de usuario"
            />
          </div>
          <div *ngIf="loginForm.get('username')?.touched && loginForm.get('username')?.invalid" class="mt-1 text-xs text-ionic-danger">
            <div *ngIf="loginForm.get('username')?.errors?.['required']">El nombre de usuario es requerido</div>
          </div>
        </div>

        <div class="mb-6">
          <label for="password" class="block text-sm font-medium text-ionic-medium mb-1">Contraseña</label>
          <div class="relative">
            <ion-icon name="lock-closed" class="absolute left-3 top-3 text-ionic-medium"></ion-icon>
            <input 
              [type]="showPassword ? 'text' : 'password'" 
              id="password" 
              formControlName="password" 
              class="pl-10 w-full py-2 px-3 border border-ionic-medium rounded-lg focus:ring-2 focus:ring-ionic-primary focus:border-ionic-primary" 
              placeholder="Tu contraseña"
            />
            <button 
              type="button" 
              (click)="togglePasswordVisibility()" 
              class="absolute inset-y-0 right-0 pr-3 flex items-center text-ionic-medium focus:outline-none"
            >
              <ion-icon [name]="showPassword ? 'eye-off-outline' : 'eye-outline'"></ion-icon>
            </button>
          </div>
          <div *ngIf="loginForm.get('password')?.touched && loginForm.get('password')?.invalid" class="mt-1 text-xs text-ionic-danger">
            <div *ngIf="loginForm.get('password')?.errors?.['required']">La contraseña es requerida</div>
            <div *ngIf="loginForm.get('password')?.errors?.['minlength']">La contraseña debe tener al menos 6 caracteres</div>
          </div>
        </div>

        <div class="flex items-center justify-between mb-6">
          <div class="flex items-center">
            <input 
              id="remember-me" 
              type="checkbox" 
              formControlName="rememberMe" 
              class="h-4 w-4 text-ionic-primary focus:ring-ionic-primary border-ionic-medium rounded"
            />
            <label for="remember-me" class="ml-2 block text-sm text-ionic-medium">Recordarme</label>
          </div>
          <a href="#" class="text-sm font-medium text-ionic-primary hover:text-ionic-secondary">¿Olvidaste tu contraseña?</a>
        </div>

        <div>
          <button 
            type="submit" 
            [disabled]="isSubmitting" 
            class="w-full bg-ionic-primary hover:bg-ionic-secondary text-white py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-ionic-primary transition duration-150 ease-in-out flex justify-center items-center"
          >
            <ion-spinner *ngIf="isSubmitting" name="crescent" class="mr-2"></ion-spinner>
            {{ isSubmitting ? 'Iniciando sesión...' : 'Iniciar sesión' }}
          </button>
        </div>
      </form>

      <div class="mt-6">
        <div class="relative">
          <div class="absolute inset-0 flex items-center">
            <div class="w-full border-t border-ionic-medium"></div>
          </div>
          <div class="relative flex justify-center text-sm">
            <span class="px-2 bg-ionic-light text-ionic-medium">O continúa con</span>
          </div>
        </div>

        <div class="mt-6 grid grid-cols-2 gap-3">
          <a href="#" class="flex justify-center items-center py-2 px-4 border border-ionic-medium rounded-lg shadow-sm bg-ionic-light hover:bg-ionic-medium">
            <ion-icon name="logo-google" class="text-xl text-red-500 mr-2"></ion-icon>
            <span class="text-sm font-medium text-ionic-dark">Google</span>
          </a>
          <a href="#" class="flex justify-center items-center py-2 px-4 border border-ionic-medium rounded-lg shadow-sm bg-ionic-light hover:bg-ionic-medium">
            <ion-icon name="logo-facebook" class="text-xl text-ionic-primary mr-2"></ion-icon>
            <span class="text-sm font-medium text-ionic-dark">Facebook</span>
          </a>
        </div>
      </div>

      <div class="mt-6 text-center">
        <p class="text-sm text-ionic-medium">
          ¿No tienes una cuenta?
          <a href="/signin"  class="font-medium text-ionic-primary hover:text-ionic-secondary">Regístrate</a>
        </p>
      </div>
    </div>
  </div>
</ion-content>

================
File: src/app/pages/login/login.page.spec.ts
================
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { LoginPage } from './login.page';

describe('LoginPage', () => {
  let component: LoginPage;
  let fixture: ComponentFixture<LoginPage>;

  beforeEach(() => {
    fixture = TestBed.createComponent(LoginPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/pages/login/login.page.ts
================
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { IonContent, IonHeader, IonTitle, IonToolbar, IonIcon, IonSpinner} from '@ionic/angular/standalone';
import { UserRequest } from '../../services/requests/users.request';
import { HttpClientModule } from '@angular/common/http';
import { addIcons } from 'ionicons';
import { eyeOutline, eyeOffOutline, mailOutline, lockClosedOutline, logoGoogle, logoFacebook, person, lockClosed } from 'ionicons/icons';
import { ToastController } from '@ionic/angular';

@Component({
  selector: 'app-login',
  templateUrl: './login.page.html',
  styleUrls: ['./login.page.scss'],
  standalone: true,
  imports: [
    IonIcon, 
    IonContent, 
    IonHeader, 
    IonTitle, 
    IonToolbar, 
    IonSpinner, 
    CommonModule, 
    FormsModule, 
    ReactiveFormsModule,
    HttpClientModule,
  ]
})
export class LoginPage {
  loginForm: FormGroup;
  isSubmitting = false;
  showPassword = false;

  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private usersService: UserRequest,
    private toastController: ToastController
  ) {
    // Añadir iconos que utilizamos en el template
    addIcons({lockClosed,person,logoGoogle,logoFacebook,eyeOutline,eyeOffOutline,mailOutline,lockClosedOutline});

    this.loginForm = this.formBuilder.group({
      username: ['', [Validators.required]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      rememberMe: [false]
    });
  }

  async onSubmit() {
    if (this.loginForm.invalid) {
      Object.keys(this.loginForm.controls).forEach(key => {
        const control = this.loginForm.get(key);
        if (control?.invalid) {
          control.markAsTouched();
        }
      });
      return;
    }

    this.isSubmitting = true;
    try {
      const { username, password } = this.loginForm.value;
      this.usersService.login(username, password).subscribe({
        next: (response) => {
          console.log('Login exitoso:', response);
          if (this.loginForm.value.rememberMe) {
            localStorage.setItem('userData', JSON.stringify(response.message));
          } else {
            sessionStorage.setItem('userData', JSON.stringify(response.message));
          }
          
          this.router.navigate(['/home'],{
            state:{
              user: response.message
            }
          });
        },
        error: async (error) => {
          console.error('Error al iniciar sesión:', error);
          const toast = await this.toastController.create({
            message: error.error?.error || 'Error al iniciar sesión',
            duration: 3000,
            position: 'top',
            color: 'danger'
          });
          toast.present();
        },
        complete: () => {
          this.isSubmitting = false;
        }
      });
    } catch (error) {
      console.error('Error inesperado:', error);
      this.isSubmitting = false;
    }
  }

  togglePasswordVisibility() {
    this.showPassword = !this.showPassword;
  }
}

================
File: src/app/pages/signin/signin.page.html
================
<ion-content class="bg-gradient-to-br from-ionic-primary to-ionic-tertiary">
  <div class="flex min-h-full items-center justify-center py-12 px-4">
    <div class="w-full max-w-md bg-ionic-light rounded-xl shadow-lg p-8">

      <div class="text-center mb-8">
        <ion-icon name="person-add" class="text-6xl text-ionic-primary"></ion-icon>
        <h2 class="mt-3 text-2xl font-bold text-ionic-dark">Crear Cuenta</h2>
        <p class="mt-2 text-sm text-ionic-medium">Completa el formulario para registrarte</p>
      </div>

      <form [formGroup]="signinForm" (ngSubmit)="onSubmit()">
        <!-- Nombre -->
        <div class="mb-4">
          <label for="nombre" class="block text-sm font-medium text-ionic-medium mb-1">Nombre</label>
          <div class="relative">
            <ion-icon name="person-outline" class="absolute left-3 top-3 text-ionic-medium"></ion-icon>
            <input 
              type="text" 
              id="nombre" 
              formControlName="nombre" 
              class="pl-10 w-full py-2 px-3 border border-ionic-medium rounded-lg focus:ring-2 focus:ring-ionic-primary focus:border-ionic-primary" 
              placeholder="Tu nombre"
            />
          </div>
          <div *ngIf="signinForm.get('nombre')?.touched && signinForm.get('nombre')?.invalid" class="mt-1 text-xs text-ionic-danger">
            <div *ngIf="signinForm.get('nombre')?.errors?.['required']">El nombre es requerido</div>
          </div>
        </div>

        <!-- Apellidos -->
        <div class="mb-4">
          <label for="apellidos" class="block text-sm font-medium text-ionic-medium mb-1">Apellidos</label>
          <div class="relative">
            <ion-icon name="person-outline" class="absolute left-3 top-3 text-ionic-medium"></ion-icon>
            <input 
              type="text" 
              id="apellidos" 
              formControlName="apellidos" 
              class="pl-10 w-full py-2 px-3 border border-ionic-medium rounded-lg focus:ring-2 focus:ring-ionic-primary focus:border-ionic-primary" 
              placeholder="Tus apellidos"
            />
          </div>
          <div *ngIf="signinForm.get('apellidos')?.touched && signinForm.get('apellidos')?.invalid" class="mt-1 text-xs text-ionic-danger">
            <div *ngIf="signinForm.get('apellidos')?.errors?.['required']">Los apellidos son requeridos</div>
          </div>
        </div>

        <!-- Email -->
        <div class="mb-4">
          <label for="email" class="block text-sm font-medium text-ionic-medium mb-1">Email</label>
          <div class="relative">
            <ion-icon name="mail-outline" class="absolute left-3 top-3 text-ionic-medium"></ion-icon>
            <input 
              type="email" 
              id="email" 
              formControlName="email" 
              class="pl-10 w-full py-2 px-3 border border-ionic-medium rounded-lg focus:ring-2 focus:ring-ionic-primary focus:border-ionic-primary" 
              placeholder="tucorreo@ejemplo.com"
            />
          </div>
          <div *ngIf="signinForm.get('email')?.touched && signinForm.get('email')?.invalid" class="mt-1 text-xs text-ionic-danger">
            <div *ngIf="signinForm.get('email')?.errors?.['required']">El email es requerido</div>
            <div *ngIf="signinForm.get('email')?.errors?.['email']">Ingresa un email válido</div>
          </div>
        </div>

        <!-- Username -->
        <div class="mb-4">
          <label for="username" class="block text-sm font-medium text-ionic-medium mb-1">Nombre de usuario</label>
          <div class="relative">
            <ion-icon name="person-outline" class="absolute left-3 top-3 text-ionic-medium"></ion-icon>
            <input 
              type="text" 
              id="username" 
              formControlName="username" 
              class="pl-10 w-full py-2 px-3 border border-ionic-medium rounded-lg focus:ring-2 focus:ring-ionic-primary focus:border-ionic-primary" 
              placeholder="Tu nombre de usuario"
            />
          </div>
          <div *ngIf="signinForm.get('username')?.touched && signinForm.get('username')?.invalid" class="mt-1 text-xs text-ionic-danger">
            <div *ngIf="signinForm.get('username')?.errors?.['required']">El nombre de usuario es requerido</div>
          </div>
        </div>

        <!-- Password -->
        <div class="mb-4">
          <label for="password" class="block text-sm font-medium text-ionic-medium mb-1">Contraseña</label>
          <div class="relative">
            <ion-icon name="lock-closed-outline" class="absolute left-3 top-3 text-ionic-medium"></ion-icon>
            <input 
              [type]="showPassword ? 'text' : 'password'" 
              id="password" 
              formControlName="password" 
              class="pl-10 w-full py-2 px-3 border border-ionic-medium rounded-lg focus:ring-2 focus:ring-ionic-primary focus:border-ionic-primary" 
              placeholder="Tu contraseña"
            />
            <button 
              type="button" 
              (click)="togglePasswordVisibility()" 
              class="absolute inset-y-0 right-0 pr-3 flex items-center text-ionic-medium focus:outline-none"
            >
              <ion-icon [name]="showPassword ? 'eye-off-outline' : 'eye-outline'"></ion-icon>
            </button>
          </div>
          <div *ngIf="signinForm.get('password')?.touched && signinForm.get('password')?.invalid" class="mt-1 text-xs text-ionic-danger">
            <div *ngIf="signinForm.get('password')?.errors?.['required']">La contraseña es requerida</div>
            <div *ngIf="signinForm.get('password')?.errors?.['minlength']">La contraseña debe tener al menos 6 caracteres</div>
          </div>
        </div>

        <!-- Foto de perfil -->
        <div class="mb-6">
          <label for="pfp" class="block text-sm font-medium text-ionic-medium mb-1">Foto de perfil</label>
          <div class="flex items-center space-x-4">
            <div *ngIf="previewUrl" class="w-16 h-16 rounded-full overflow-hidden bg-gray-100 flex-shrink-0">
              <img [src]="previewUrl" alt="Vista previa" class="w-full h-full object-cover">
            </div>
            <div class="flex-grow">
              <label class="cursor-pointer flex items-center justify-center w-full py-2 px-3 border border-ionic-medium rounded-lg hover:bg-ionic-medium/10 transition-colors">
                <ion-icon name="image-outline" class="mr-2 text-ionic-medium"></ion-icon>
                <span class="text-sm text-ionic-medium">{{ selectedFile ? selectedFile.name : 'Seleccionar imagen' }}</span>
                <input 
                  type="file" 
                  id="pfp" 
                  accept="image/*" 
                  class="hidden" 
                  (change)="onFileChange($event)"
                />
              </label>
            </div>
          </div>
          <div *ngIf="signinForm.get('pfp')?.touched && signinForm.get('pfp')?.invalid" class="mt-1 text-xs text-ionic-danger">
            <div *ngIf="signinForm.get('pfp')?.errors?.['required']">La foto de perfil es requerida</div>
          </div>
        </div>

        <div>
          <button 
            type="submit" 
            [disabled]="isSubmitting || signinForm.invalid" 
            class="w-full bg-ionic-primary hover:bg-ionic-secondary text-white py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-ionic-primary transition duration-150 ease-in-out flex justify-center items-center"
          >
            <ion-spinner *ngIf="isSubmitting" name="crescent" class="mr-2"></ion-spinner>
            {{ isSubmitting ? 'Registrando...' : 'Registrarse' }}
          </button>
        </div>
      </form>

      <div class="mt-6 text-center">
        <p class="text-sm text-ionic-medium">
          ¿Ya tienes una cuenta?
          <a href='/login' class="font-medium text-ionic-primary hover:text-ionic-secondary">Iniciar sesión</a>
        </p>
      </div>
    </div>
  </div>
</ion-content>

================
File: src/app/pages/signin/signin.page.spec.ts
================
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { SigninPage } from './signin.page';

describe('SigninPage', () => {
  let component: SigninPage;
  let fixture: ComponentFixture<SigninPage>;

  beforeEach(() => {
    fixture = TestBed.createComponent(SigninPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/pages/signin/signin.page.ts
================
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { HttpClientModule } from '@angular/common/http';
import { IonContent, IonHeader, IonTitle, IonToolbar, IonIcon, IonSpinner } from '@ionic/angular/standalone';
import { UserRequest } from '../../services/requests/users.request';
import { ToastController } from '@ionic/angular';
import { addIcons } from 'ionicons';
import { personOutline, mailOutline, lockClosedOutline, eyeOutline, eyeOffOutline, imageOutline, personAdd } from 'ionicons/icons';

@Component({
  selector: 'app-signin',
  templateUrl: './signin.page.html',
  styleUrls: ['./signin.page.scss'],
  standalone: true,
  imports: [
    IonContent, 
    IonHeader, 
    IonTitle, 
    IonToolbar, 
    IonIcon,
    IonSpinner,
    CommonModule, 
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule
  ]
})
export class SigninPage implements OnInit {
  signinForm: FormGroup;
  isSubmitting = false;
  showPassword = false;
  selectedFile: File | null = null;
  previewUrl: string | ArrayBuffer | null = null;

  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private usersService: UserRequest,
    private toastController: ToastController
  ) {
    // Añadir iconos
    addIcons({personAdd,personOutline,mailOutline,lockClosedOutline,imageOutline,eyeOutline,eyeOffOutline});

    this.signinForm = this.formBuilder.group({
      nombre: ['', [Validators.required]],
      apellidos: ['', [Validators.required]],
      email: ['', [Validators.required, Validators.email]],
      username: ['', [Validators.required]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      pfp: [null, [Validators.required]]
    });
  }

  ngOnInit() {
  }

  onFileChange(event: Event) {
    const fileInput = event.target as HTMLInputElement;
    if (fileInput.files && fileInput.files.length) {
      this.selectedFile = fileInput.files[0];
      this.signinForm.patchValue({
        pfp: this.selectedFile
      });
      
      // Crear una vista previa de la imagen
      const reader = new FileReader();
      reader.onload = () => {
        this.previewUrl = reader.result;
      };
      reader.readAsDataURL(this.selectedFile);
    }
  }

  togglePasswordVisibility() {
    this.showPassword = !this.showPassword;
  }

  async onSubmit() {
    if (this.signinForm.invalid) {
      Object.keys(this.signinForm.controls).forEach(key => {
        const control = this.signinForm.get(key);
        if (control?.invalid) {
          control.markAsTouched();
        }
      });
      return;
    }

    this.isSubmitting = true;
    
    try {
      // Crear FormData para enviar los datos incluyendo el archivo
      const formData = new FormData();
      Object.keys(this.signinForm.value).forEach(key => {
        if (key === 'pfp' && this.selectedFile) {
          formData.append(key, this.selectedFile, this.selectedFile.name);
        } else {
          formData.append(key, this.signinForm.value[key]);
        }
      });

      this.usersService.register(formData).subscribe({
        next: async (response) => {
          console.log('Registro exitoso:', response);
          const toast = await this.toastController.create({
            message: 'Registro completado con éxito',
            duration: 3000,
            position: 'top',
            color: 'success'
          });
          toast.present();
          this.router.navigate(['/login']);
        },
        error: async (error) => {
          console.error('Error al registrar:', error);
          const toast = await this.toastController.create({
            message: error.error?.error || 'Error al registrar usuario',
            duration: 3000,
            position: 'top',
            color: 'danger'
          });
          toast.present();
        },
        complete: () => {
          this.isSubmitting = false;
        }
      });
    } catch (error) {
      console.error('Error inesperado:', error);
      this.isSubmitting = false;
    }
  }
}

================
File: src/app/pages/tabs/tabs.page.html
================
<ion-tabs>
  <ion-tab-bar slot="bottom">
    <ion-tab-button tab="home" routerLink="/tabs/home" routerLinkActive="tab-selected">
      <ion-icon aria-hidden="true" name="home-outline"></ion-icon>
      <ion-label>Home</ion-label>
    </ion-tab-button>
    
    <ion-tab-button tab="friends" routerLink="/tabs/friends" routerLinkActive="tab-selected">
      <ion-icon aria-hidden="true" name="people-outline"></ion-icon>
      <ion-label>Friends</ion-label>
    </ion-tab-button>
  </ion-tab-bar>
</ion-tabs>

================
File: src/app/pages/tabs/tabs.page.spec.ts
================
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { TabsPage } from './tabs.page';

describe('TabsPage', () => {
  let component: TabsPage;
  let fixture: ComponentFixture<TabsPage>;

  beforeEach(() => {
    fixture = TestBed.createComponent(TabsPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});

================
File: src/app/pages/tabs/tabs.page.ts
================
import { Component } from '@angular/core';
import { IonTabs, IonTabBar, IonTabButton, IonIcon, IonLabel, IonHeader, IonToolbar, IonTitle, IonContent } from '@ionic/angular/standalone';
import { addIcons } from 'ionicons';
import { homeOutline, searchOutline, peopleOutline } from 'ionicons/icons';
import { RouterLink, RouterLinkActive } from '@angular/router';

@Component({
  selector: 'app-tabs',
  templateUrl: 'tabs.page.html',
  styleUrls: ['tabs.page.scss'],
  standalone: true,
  imports: [IonTabs, IonTabBar, IonTabButton, IonIcon, IonLabel, RouterLink, RouterLinkActive]
})
export class TabsPage {
  constructor() {
    addIcons({homeOutline,peopleOutline,searchOutline});
  }
}

================
File: src/app/services/facades/audius.facade.spec.ts
================
import { TestBed } from '@angular/core/testing';

import { AudiusFacade } from './audius.facade';

describe('AudiusService', () => {
  let service: AudiusFacade;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(AudiusFacade);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});

================
File: src/app/services/facades/audius.facade.ts
================
import { Injectable } from '@angular/core';
import { AudiusRequest } from '../requests/audius.request';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class AudiusFacade {
  constructor(private audiusRequest: AudiusRequest) {}

  search(query: string): Observable<any> {
    return this.audiusRequest.searchContent(query);
  }

  tracks(): Observable<any> {
    return this.audiusRequest.getTrendingTracks();
  }

  playlists(): Observable<any> {
    return this.audiusRequest.getPlaylists();
  }

  playlistTracks(playlistId: string): Observable<any> {
    return this.audiusRequest.getPlaylistTracks(playlistId);
  }

  getPlaylistById(playlistId: string): Observable<any> {
    return this.audiusRequest.getPlaylistById(playlistId);
  }

  getTrackById(trackId: string): Observable<any> {
    return this.audiusRequest.getTrackById(trackId);
  }

  async play(trackId: string, playlist?: any[]) {
    if (playlist) {
      this.audiusRequest.setCurrentPlaylist(playlist, trackId);
    }
    await this.audiusRequest.playTrack(trackId);
  }

  pause(): void {
    this.audiusRequest.pauseTrack();
  }

  stop(): void {
    this.audiusRequest.stopCurrentTrack();
  }

  next(): void {
    this.audiusRequest.playNextTrack();
  }

  previous(): void {
    this.audiusRequest.playPreviousTrack();
  }

  seekTo(position: number): void {
    this.audiusRequest.seekTo(position);
  }

  isPlaying(): Observable<boolean> {
    return this.audiusRequest.isPlaying$;
  }

  getCurrentTrackId(): Observable<string | null> {
    return this.audiusRequest.currentTrackId$;
  }

  getCurrentTime(): Observable<number> {
    return this.audiusRequest.currentTime$;
  }

  getDuration(): Observable<number> {
    return this.audiusRequest.duration$;
  }

  getCurrentPlaylist(): Observable<any[] | null> {
    return this.audiusRequest.currentPlaylist$;
  }

  getCurrentTrackIndex(): Observable<number> {
    return this.audiusRequest.currentTrackIndex$;
  }

  formatTime(time: number): string {
    return this.audiusRequest.formatTime(time);
  }
}

================
File: src/app/services/facades/users.facade.spec.ts
================
import { TestBed } from '@angular/core/testing';

import { UserRequest } from './users.facade';

describe('UsersService', () => {
  let service: UserRequest;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(UserRequest);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});

================
File: src/app/services/facades/users.facade.ts
================
import { Injectable } from '@angular/core';
import { UserRequest } from '../requests/users.request';
@Injectable({
  providedIn: 'root'
})
export class UserFacade {

  constructor(private userRequest:UserRequest) { }

  login(username: string, password: string) {
    return this.userRequest.login(username, password);
  }
  register(userData: FormData) {
    return this.userRequest.register(userData);
  }
  updateUserData(userData: FormData) {
    return this.userRequest.updateUserData(userData);
  }
  getUserById(userId: string) {
    return this.userRequest.getUserById(userId);
  }
}

================
File: src/app/services/requests/audius.request.spec.ts
================
import { TestBed } from '@angular/core/testing';

import { AudiusRequest } from './audius.request';

describe('AudiusService', () => {
  let service: AudiusRequest;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(AudiusRequest);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});

================
File: src/app/services/requests/audius.request.ts
================
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { catchError, Observable, of, tap, BehaviorSubject, switchMap } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class AudiusRequest {
  private readonly API_URL = 'https://discoveryprovider.audius.co/v1';
  private readonly APP_NAME = 'amuzik';
  private currentAudio: HTMLAudioElement | null = null;
  private trackPositions: Map<string, number> = new Map();

  private currentTrackIdSubject = new BehaviorSubject<string | null>(null);
  public currentTrackId$ = this.currentTrackIdSubject.asObservable();

  private isPlayingSubject = new BehaviorSubject<boolean>(false);
  public isPlaying$ = this.isPlayingSubject.asObservable();

  private currentTimeSubject = new BehaviorSubject<number>(0);
  public currentTime$ = this.currentTimeSubject.asObservable();

  private durationSubject = new BehaviorSubject<number>(0);
  public duration$ = this.durationSubject.asObservable();

  private currentPlaylistSubject = new BehaviorSubject<any[] | null>(null);
  public currentPlaylist$ = this.currentPlaylistSubject.asObservable();

  private currentTrackIndexSubject = new BehaviorSubject<number>(-1);
  public currentTrackIndex$ = this.currentTrackIndexSubject.asObservable();

  private cache = new Map<string, any>();

  constructor(private http: HttpClient) {
    // Actualizar el tiempo de reproducción cada segundo
    setInterval(() => {
      if (this.currentAudio && !this.currentAudio.paused) {
        this.currentTimeSubject.next(this.currentAudio.currentTime);
      }
    }, 1000);
  }

  searchContent(query: string): Observable<any> {
    return this.http.get(`${this.API_URL}/tracks/search?query=${encodeURIComponent(query)}&app_name=${this.APP_NAME}`).pipe(
      tap(response => {
        console.log('Track search results:', response);
      }),
      catchError(error => {
        console.error('Error en la búsqueda de tracks:', error);
        return of({ data: [] });
      })
    );
  }

  getPlaylistTracks(playlistId: string): Observable<any> {
    const cacheKey = `playlist_${playlistId}`;
    if (this.cache.has(cacheKey)) {
      return of(this.cache.get(cacheKey));
    }
    return this.http
      .get(`${this.API_URL}/playlists/${playlistId}/tracks?app_name=${this.APP_NAME}`)
      .pipe(
        tap((response) => {
          console.log('Tracks de la playlist recibidos:', response);
          this.cache.set(cacheKey, response);
        }),
        catchError((error) => {
          console.error('Error al obtener tracks de la playlist:', error);
          return of({ data: [] });
        })
      );
  }

  getTrendingTracks(): Observable<any> {
    return this.http
      .get(`${this.API_URL}/tracks/trending?app_name=${this.APP_NAME}`)
      .pipe(
        tap((response) => {
          console.log('Tracks recibidos:', response);
        }),
        catchError((error) => {
          console.error('Error al obtener tracks:', error);
          return of({ data: [] });
        })
      );
  }

  getPlaylists(): Observable<any> {
    return this.http
      .get(`${this.API_URL}/playlists/trending?app_name=${this.APP_NAME}`)
      .pipe(
        tap((response) => {
          console.log('Playlists recibidos:', response);
        }),
        catchError((error) => {
          console.error('Error al obtener playlists:', error);
          return of({ data: [] });
        })
      );
  }

  getPlaylistById(playlistId: string): Observable<any> {
    return this.http
      .get(`${this.API_URL}/playlists/${playlistId}?app_name=${this.APP_NAME}`)
      .pipe(
        tap((response) => {
          console.log('Playlist obtenida:', response);
        }),
        catchError((error) => {
          console.error('Error al obtener playlist:', error);
          return of(null);
        })
      );
  }

  getTrackById(trackId: string): Observable<any> {
    return this.http
      .get(`${this.API_URL}/tracks/${trackId}?app_name=${this.APP_NAME}`)
      .pipe(
        tap((response) => {
          console.log('Track obtenido:', response);
        }),
        catchError((error) => {
          console.error('Error al obtener track:', error);
          return of(null);
        })
      );
  }

  async getTrackStreamUrl(trackId: string): Promise<string> {
    try {
      const response = await fetch(
        `${this.API_URL}/tracks/${trackId}/stream?app_name=${this.APP_NAME}`,
        {
          mode: 'cors',
        }
      );
      if (!response.ok) {
        throw new Error(`Error al obtener el stream: ${response.statusText}`);
      }
      return response.url;
    } catch (error) {
      console.error('Error obteniendo la URL de streaming:', error);
      return '';
    }
  }

  setCurrentPlaylist(playlist: any[] | null, initialTrackId?: string) {
    if (!playlist || playlist.length === 0) {
      this.currentPlaylistSubject.next(null);
      this.currentTrackIndexSubject.next(-1);
      return;
    }
    
    // Normalizar los IDs de las canciones en la playlist
    const normalizedPlaylist = playlist.map(track => ({
      ...track,
      id: track.track_id || track.id // Asegurar consistencia en IDs
    }));
    
    this.currentPlaylistSubject.next(normalizedPlaylist);
    
    if (initialTrackId) {
      const trackIndex = normalizedPlaylist.findIndex(track => 
        (track.id === initialTrackId || track.track_id === initialTrackId)
      );
      
      if (trackIndex !== -1) {
        console.log(`Estableciendo índice inicial: ${trackIndex} para track: ${initialTrackId}`);
        this.currentTrackIndexSubject.next(trackIndex);
      } else {
        console.warn(`No se encontró el track ${initialTrackId} en la playlist`);
        // Si no se encuentra, establecer el primero como actual
        this.currentTrackIndexSubject.next(0);
      }
    } else if (normalizedPlaylist.length > 0) {
      // Si no se especifica track inicial, usar el primero
      this.currentTrackIndexSubject.next(0);
    }
  }

  async playTrack(trackId: string | undefined) {
    if (!trackId) {
      console.error('Error: trackId es undefined. No se puede reproducir.');
      return;
    }
  
    console.log(`Intentando reproducir track: ${trackId}`);
    const isCurrentTrack = this.currentTrackIdSubject.value === trackId;
  
    if (isCurrentTrack && this.currentAudio) {
      this.currentAudio.play().catch((error) => {
        console.error('Error al reanudar reproducción:', error);
      });
      this.isPlayingSubject.next(true);
      return;
    }
  
    // Guardar el progreso del track actual antes de cambiarlo
    if (this.currentAudio && this.currentTrackIdSubject.value) {
      this.trackPositions.set(
        this.currentTrackIdSubject.value, 
        this.currentAudio.currentTime
      );
    }
  
    if (!isCurrentTrack) {
      this.stopCurrentTrack(false); // No resetear la playlist actual
  
      const streamUrl = await this.getTrackStreamUrl(trackId);
      if (!streamUrl) {
        console.error(
          `No se pudo obtener la URL de streaming para el track ID: ${trackId}`
        );
        return;
      }
  
      this.currentAudio = new Audio();
      this.currentAudio.src = streamUrl;
  
      const savedPosition = this.trackPositions.get(trackId);
      if (savedPosition !== undefined) {
        this.currentAudio.currentTime = savedPosition;
      }
  
      this.setupAudioEventHandlers(trackId);
    }
  
    this.currentAudio?.play().catch((error) => {
      console.error('Error al intentar reproducir:', error);
    });
  
    this.currentTrackIdSubject.next(trackId);
    this.isPlayingSubject.next(true);
    
    // Actualizar índice en la playlist actual
    const currentPlaylist = this.currentPlaylistSubject.value;
    if (currentPlaylist) {
      const trackIndex = currentPlaylist.findIndex(track => 
        (track.track_id === trackId || track.id === trackId)
      );
      
      if (trackIndex !== -1) {
        console.log(`Actualizando índice actual a: ${trackIndex}`);
        this.currentTrackIndexSubject.next(trackIndex);
      } else {
        console.warn(`Track ${trackId} no encontrado en la playlist actual`);
      }
    }
  }

  private setupAudioEventHandlers(trackId: string) {
    if (!this.currentAudio) return;

    // Restablecer la duración inicial
    this.durationSubject.next(0);

    // Cuando se carga los metadatos, actualizar la duración
    this.currentAudio.onloadedmetadata = () => {
      if (this.currentAudio) {
        this.durationSubject.next(this.currentAudio.duration);
      }
    };

    // Almacenar la posición actual del track cada 5 segundos
    const updateInterval = setInterval(() => {
      if (this.currentAudio && !this.currentAudio.paused) {
        this.trackPositions.set(trackId, this.currentAudio.currentTime);
        this.currentTimeSubject.next(this.currentAudio.currentTime);
      }
    }, 5000);

    this.currentAudio.ontimeupdate = () => {
      if (this.currentAudio) {
        this.currentTimeSubject.next(this.currentAudio.currentTime);
      }
    };

    this.currentAudio.onended = () => {
      console.log('Track finalizado');
      this.isPlayingSubject.next(false);
      this.trackPositions.delete(trackId);
      clearInterval(updateInterval);
      
      // Reproducir siguiente track si está en una playlist
      this.playNextTrack();
    };

    this.currentAudio.onerror = () => {
      console.error('Error durante reproducción de audio');
      this.isPlayingSubject.next(false);
      clearInterval(updateInterval);
    };
  }

  pauseTrack() {
    if (this.currentAudio) {
      this.currentAudio.pause();

      // Mantener la posición actual del track
      const currentTrackId = this.currentTrackIdSubject.value;
      if (currentTrackId) {
        this.trackPositions.set(currentTrackId, this.currentAudio.currentTime);
      }

      this.isPlayingSubject.next(false);
    }
  }

  stopCurrentTrack(resetPlaylist: boolean = true) {
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio.currentTime = 0;
      this.currentAudio = null;
    }
  
    this.currentTrackIdSubject.next(null);
    this.isPlayingSubject.next(false);
    this.currentTimeSubject.next(0);
    this.durationSubject.next(0);
    
    if (resetPlaylist) {
      this.currentPlaylistSubject.next(null);
      this.currentTrackIndexSubject.next(-1);
    }
  }

  isPlaying(): boolean {
    return this.isPlayingSubject.value;
  }

  getCurrentTrackId(): string | null {
    return this.currentTrackIdSubject.value;
  }

  getCurrentTime(): number {
    return this.currentTimeSubject.value;
  }

  getDuration(): number {
    return this.durationSubject.value;
  }

  seekTo(position: number) {
    if (this.currentAudio) {
      this.currentAudio.currentTime = position;
      this.currentTimeSubject.next(position);

      const currentTrackId = this.currentTrackIdSubject.value;
      if (currentTrackId) {
        this.trackPositions.set(currentTrackId, position);
      }
    }
  } 
  
  playNextTrack() {
    const currentPlaylist = this.currentPlaylistSubject.value;
    const currentIndex = this.currentTrackIndexSubject.value;
    
    console.log(`Intentando reproducir siguiente track. Índice actual: ${currentIndex}, Playlist length: ${currentPlaylist?.length || 0}`);
    
    if (currentPlaylist && currentIndex !== -1 && currentIndex < currentPlaylist.length - 1) {
      const nextTrack = currentPlaylist[currentIndex + 1];
      const nextTrackId = nextTrack.track_id || nextTrack.id;
      if (nextTrackId) {
        console.log(`Reproduciendo siguiente track: ${nextTrackId}`);
        this.playTrack(nextTrackId);
      } else {
        console.warn('El siguiente track no tiene ID válido');
      }
    } else {
      console.log('No hay más tracks en la playlist o no hay playlist activa');
      // Si no hay playlist o estamos en el último track, intentamos encontrar uno similar
      this.findSimilarTrack(this.currentTrackIdSubject.value);
    }
  }
  
  // Nueva función para encontrar tracks similares
  private findSimilarTrack(currentTrackId: string | null) {
    if (!currentTrackId) return;
    
    this.getTrackById(currentTrackId).pipe(
      switchMap(trackData => {
        if (!trackData?.data) return of(null);
        
        const genre = trackData.data.genre;
        
        if (genre) {
          return this.http.get(`${this.API_URL}/tracks/trending?genre=${encodeURIComponent(genre)}&app_name=${this.APP_NAME}`)
            .pipe(
              catchError(() => of({ data: [] }))
            );
        }
        
        return of(null);
      }),
      catchError(() => of({ data: [] }))
    ).subscribe((response: any) => {
      if (response?.data && response.data.length > 0) {
        // Filtrar el track actual
        const similarTracks = response.data.filter((t: any) => t.id !== currentTrackId);
        
        if (similarTracks.length > 0) {
          const randomIndex = Math.floor(Math.random() * similarTracks.length);
          const nextTrack = similarTracks[randomIndex];
          
          // Crear una nueva playlist con tracks similares
          this.setCurrentPlaylist(similarTracks, nextTrack.id);
          this.playTrack(nextTrack.id);
        } else {
          this.findRandomTrack();
        }
      } else {
        this.findRandomTrack();
      }
    });
  }
  
  // Método auxiliar para encontrar un track aleatorio
  private findRandomTrack() {
    this.http.get(`${this.API_URL}/tracks/trending?app_name=${this.APP_NAME}`)
      .pipe(
        catchError(() => of({ data: [] }))
      )
      .subscribe((response: any) => {
        if (response?.data && response.data.length > 0) {
          const randomIndex = Math.floor(Math.random() * response.data.length);
          const randomTrack = response.data[randomIndex];
          
          if (randomTrack?.id) {
            this.setCurrentPlaylist(response.data);
            this.playTrack(randomTrack.id);
          }
        }
      });
  }
  
  playPreviousTrack() {
    const currentPlaylist = this.currentPlaylistSubject.value;
    const currentIndex = this.currentTrackIndexSubject.value;
    
    console.log(`Intentando reproducir track anterior. Índice actual: ${currentIndex}`);
    
    // Si la posición actual es mayor a 3 segundos, volver al inicio de la canción
    if (this.currentAudio && this.currentAudio.currentTime > 3) {
      console.log('Volviendo al inicio de la canción actual');
      this.seekTo(0);
      return;
    }
    
    // Si no, ir a la canción anterior
    if (currentPlaylist && currentIndex > 0) {
      const prevTrack = currentPlaylist[currentIndex - 1];
      const prevTrackId = prevTrack.track_id || prevTrack.id;
      if (prevTrackId) {
        console.log(`Reproduciendo track anterior: ${prevTrackId}`);
        this.playTrack(prevTrackId);
      } else {
        console.warn('El track anterior no tiene ID válido');
      }
    } else {
      console.log('Ya estás en el primer track o no hay playlist activa');
    }
  }

  formatTime(time: number): string {
    if (isNaN(time)) return '0:00';
    
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
  }
}

================
File: src/app/services/requests/users.request.spec.ts
================
import { TestBed } from '@angular/core/testing';

import { UserRequest } from './users.request';

describe('UsersService', () => {
  let service: UserRequest;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(UserRequest);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});

================
File: src/app/services/requests/users.request.ts
================
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';
import { environment } from '../../../environments/environment';

@Injectable({
  providedIn: 'root'
})
export class UserRequest {
  private apiUrl = environment.apiUrl;
  private token = 'W66jQhYGGzEIuCcAXfpTJkt7uH6GBGpcJLCSXo6O2WF1AZkxiMXpypFaKEfA';

  constructor(private http: HttpClient) { }

  login(username: string, password: string): Observable<any> {
    const headers = new HttpHeaders({
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${this.token}`
    });

    const body = {
      username,
      password
    };

    return this.http.post(`${this.apiUrl}find`, body, { headers });
  }

  register(userData: FormData): Observable<any> {
    const headers = new HttpHeaders({
      'Authorization': `Bearer ${this.token}`
    });

    return this.http.post(`${this.apiUrl}sign`, userData, { headers });
  }

  updateUserData(userData: FormData): Observable<any> {
    const headers = new HttpHeaders({
      'Authorization': `Bearer ${this.token}`
    });
    return this.http.put(`${this.apiUrl}user`, userData, { headers });
  }

  getUserById(userId: string): Observable<any> {
    const headers = new HttpHeaders({
      'Authorization': `Bearer ${this.token}`
    });

    return this.http.get(`${this.apiUrl}user/${userId}`, { headers });
  }
}

================
File: src/app/services/config.service.spec.ts
================
import { TestBed } from '@angular/core/testing';

import { ConfigService } from './config.service';

describe('ConfigService', () => {
  let service: ConfigService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ConfigService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});

================
File: src/app/services/config.service.ts
================
// src/app/services/config.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, of } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';

export interface Usuario {
  nombre: string;
  email: string;
  foto: string;
}

export interface Configuraciones {
  cuenta: {
    idioma: string;
    tema: boolean; // false = claro, true = oscuro
  };
  notificaciones: {
    push: boolean;
    email: boolean;
    sonido: boolean;
    vibracion: boolean;
  };
  general: {
    autoGuardado: boolean;
    sincronizarDatos: boolean;
    compartirEstadisticas: boolean;
  };
}

@Injectable({
  providedIn: 'root'
})
export class ConfigService {
  private API_URL = 'https://tu-api.com/api'; // URL base de tu API (cambiar según corresponda)
  
  private configSubject = new BehaviorSubject<Configuraciones>({
    cuenta: {
      idioma: 'es',
      tema: false,
    },
    notificaciones: {
      push: true,
      email: true,
      sonido: true,
      vibracion: true
    },
    general: {
      autoGuardado: true,
      sincronizarDatos: true,
      compartirEstadisticas: false
    }
  });
  
  private usuarioSubject = new BehaviorSubject<Usuario>({
    nombre: 'Usuario Ejemplo',
    email: 'usuario@ejemplo.com',
    foto: 'https://ionicframework.com/docs/img/demos/avatar.svg'
  });

  constructor(private http: HttpClient) {
    this.cargarConfiguraciones();
    this.cargarUsuario();
  }

  // Getters para acceder a los datos
  get configuraciones$(): Observable<Configuraciones> {
    return this.configSubject.asObservable();
  }

  get configuracionesActuales(): Configuraciones {
    return this.configSubject.value;
  }

  get usuario$(): Observable<Usuario> {
    return this.usuarioSubject.asObservable();
  }

  get usuarioActual(): Usuario {
    return this.usuarioSubject.value;
  }

  // Cargar configuraciones
  cargarConfiguraciones(): void {
    // Primero intentamos cargar desde localStorage
    const configGuardadas = localStorage.getItem('configuraciones');
    if (configGuardadas) {
      this.configSubject.next(JSON.parse(configGuardadas));
    }
    
    // Opcionalmente podemos cargar desde el servidor (comentado por ahora)
    /*
    this.http.get<Configuraciones>(`${this.API_URL}/configuraciones`)
      .pipe(
        tap(config => {
          this.configSubject.next(config);
          localStorage.setItem('configuraciones', JSON.stringify(config));
        }),
        catchError(error => {
          console.error('Error al cargar configuraciones:', error);
          return of(this.configSubject.value);
        })
      )
      .subscribe();
    */
  }

  // Cargar datos del usuario
  cargarUsuario(): void {
    const usuarioGuardado = localStorage.getItem('usuario');
    if (usuarioGuardado) {
      this.usuarioSubject.next(JSON.parse(usuarioGuardado));
    }
    
    // Similar al anterior, podríamos cargar desde el servidor
  }

  // Guardar configuraciones
  guardarConfiguraciones(configuraciones: Configuraciones): Observable<Configuraciones> {
    // Actualizamos el subject y guardamos en localStorage
    this.configSubject.next(configuraciones);
    localStorage.setItem('configuraciones', JSON.stringify(configuraciones));
    
    // Si tienes un backend, podrías sincronizar con él
    // return this.http.post<Configuraciones>(`${this.API_URL}/configuraciones`, configuraciones);
    
    // Por ahora simplemente devolvemos las configuraciones
    return of(configuraciones);
  }

  // Guardar datos del usuario
  guardarUsuario(usuario: Usuario): Observable<Usuario> {
    this.usuarioSubject.next(usuario);
    localStorage.setItem('usuario', JSON.stringify(usuario));
    return of(usuario);
  }

  // Cerrar sesión
  cerrarSesion(): Observable<boolean> {
    // Eliminar datos de sesión
    localStorage.removeItem('authToken');
    return of(true);
  }
}

================
File: src/app/services/tema.service.spec.ts
================
import { TestBed } from '@angular/core/testing';

import { TemaService } from './tema.service';

describe('TemaService', () => {
  let service: TemaService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(TemaService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});

================
File: src/app/services/tema.service.ts
================
import { Injectable, Renderer2, RendererFactory2 } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

export interface TemaConfig {
  id: string;
  nombre: string;
  colorClase: string;
  colorPrincipal: string;
}

export type ModoTema = 'claro' | 'oscuro' | 'sistema';

@Injectable({
  providedIn: 'root'
})
export class TemaService {
  private renderer: Renderer2;
  private temaActualSubject = new BehaviorSubject<string>('theme-pastel-green-light');
  temaActual$ = this.temaActualSubject.asObservable();
  
  private modoOscuroSubject = new BehaviorSubject<boolean>(false);
  modoOscuro$ = this.modoOscuroSubject.asObservable();
  
  private preferenciaModoBrillo = new BehaviorSubject<ModoTema>('sistema');
  preferenciaModoBrillo$ = this.preferenciaModoBrillo.asObservable();

  // MediaQueryList para detectar el modo del sistema
  private prefiereModoOscuro: MediaQueryList;
  
  // Lista de temas disponibles
  temasDisponibles: TemaConfig[] = [
    { 
      id: 'neutral', 
      nombre: 'Color Neutro', 
      colorClase: 'theme-neutral', 
      colorPrincipal: '#666666' 
    },
    { 
      id: 'standard', 
      nombre: 'Color Standard', 
      colorClase: 'theme-standard', 
      colorPrincipal: '#3880ff' 
    },
    { 
      id: 'green', 
      nombre: 'Verde Pastel', 
      colorClase: 'theme-pastel-green', 
      colorPrincipal: '#7acb7a' 
    },
    { 
      id: 'blue', 
      nombre: 'Azul Pastel', 
      colorClase: 'theme-pastel-blue', 
      colorPrincipal: '#7fb2d9' 
    },
    { 
      id: 'purple', 
      nombre: 'Morado Pastel', 
      colorClase: 'theme-pastel-purple', 
      colorPrincipal: '#c17fd9' 
    },
    { 
      id: 'red', 
      nombre: 'Rojo Pastel', 
      colorClase: 'theme-pastel-red', 
      colorPrincipal: '#e78787' 
    },
    { 
      id: 'orange', 
      nombre: 'Naranja Pastel', 
      colorClase: 'theme-pastel-orange', 
      colorPrincipal: '#f2a76c' 
    }
  ];

  constructor(rendererFactory: RendererFactory2) {
    this.renderer = rendererFactory.createRenderer(null, null);
    
    // Configurar la detección del modo del sistema
    this.prefiereModoOscuro = window.matchMedia('(prefers-color-scheme: dark)');
    
    // Listener para cambios en la preferencia del sistema
    this.prefiereModoOscuro.addEventListener('change', (e) => {
      if (this.preferenciaModoBrillo.value === 'sistema') {
        this.cambiarModoOscuro(e.matches);
      }
    });
    
    this.inicializarTema();
  }

  private inicializarTema() {
    // Cargar preferencias guardadas
    const temaGuardado = localStorage.getItem('tema-app') || 'theme-pastel-green-light';
    const modoPreferencia = localStorage.getItem('modo-preferencia') as ModoTema || 'sistema';
    
    // Establecer la preferencia de modo
    this.preferenciaModoBrillo.next(modoPreferencia);
    
    // Determinar si debe estar en modo oscuro
    let usarModoOscuro: boolean;
    
    if (modoPreferencia === 'sistema') {
      // Usar la preferencia del sistema
      usarModoOscuro = this.prefiereModoOscuro.matches;
    } else {
      // Usar la preferencia manual
      usarModoOscuro = modoPreferencia === 'oscuro';
    }
    
    // Establecer valores iniciales
    this.modoOscuroSubject.next(usarModoOscuro);
    
    // Construir el nombre completo del tema con el modo correcto
    const baseClase = temaGuardado.split('-light')[0].split('-dark')[0];
    const nombreCompletoTema = `${baseClase}${usarModoOscuro ? '-dark' : '-light'}`;
    
    this.temaActualSubject.next(nombreCompletoTema);
    
    // Aplicar tema
    this.aplicarTema(nombreCompletoTema);
    
    // Aplicar modo oscuro si es necesario
    if (usarModoOscuro) {
      this.renderer.addClass(document.body, 'dark');
    }
  }

  cambiarTema(temaId: string) {
    // Buscar el tema por ID
    const tema = this.temasDisponibles.find(t => t.id === temaId);
    if (!tema) return;
    
    // Construir el nombre completo del tema con el modo
    const modoSufijo = this.modoOscuroSubject.value ? '-dark' : '-light';
    const nombreCompleto = `${tema.colorClase}${modoSufijo}`;
    
    // Aplicar el tema
    this.aplicarTema(nombreCompleto);
    
    // Actualizar el tema actual
    this.temaActualSubject.next(nombreCompleto);
    
    // Guardar en localStorage
    localStorage.setItem('tema-app', nombreCompleto);
  }

  cambiarModoOscuro(activar: boolean) {
    // Actualizar el estado
    this.modoOscuroSubject.next(activar);
    
    // Modificar la clase dark del body
    if (activar) {
      this.renderer.addClass(document.body, 'dark');
    } else {
      this.renderer.removeClass(document.body, 'dark');
    }
    
    // Actualizar el tema con el nuevo modo
    const temaActual = this.temaActualSubject.value;
    const baseClase = temaActual.split('-light')[0].split('-dark')[0];
    const nuevoTema = `${baseClase}${activar ? '-dark' : '-light'}`;
    
    // Aplicar el tema actualizado
    this.aplicarTema(nuevoTema);
    
    // Actualizar el tema actual
    this.temaActualSubject.next(nuevoTema);
    
    // Guardar en localStorage
    localStorage.setItem('tema-app', nuevoTema);
  }
  
  cambiarPreferenciaModo(modo: ModoTema) {
    // Guardar la preferencia
    this.preferenciaModoBrillo.next(modo);
    localStorage.setItem('modo-preferencia', modo);
    
    // Aplicar el modo correspondiente
    if (modo === 'sistema') {
      // Usar la preferencia del sistema
      this.cambiarModoOscuro(this.prefiereModoOscuro.matches);
    } else {
      // Establecer modo manual
      this.cambiarModoOscuro(modo === 'oscuro');
    }
  }

  obtenerPreferenciaModo(): ModoTema {
    return this.preferenciaModoBrillo.value;
  }

  private aplicarTema(nombreClase: string) {
    // Eliminar todas las clases de tema anteriores
    document.body.classList.forEach(clase => {
      if (clase.startsWith('theme-')) {
        this.renderer.removeClass(document.body, clase);
      }
    });
    
    // Añadir la nueva clase de tema
    this.renderer.addClass(document.body, nombreClase);
    
    // Actualizar el meta theme-color
    const metaThemeColor = document.querySelector('meta[name=theme-color]');
    if (metaThemeColor) {
      // Buscar el color principal del tema actual
      const temaIdParts = nombreClase.split('-');
      let temaId = '';
      if (temaIdParts.length >= 3) {
        temaId = temaIdParts[2];
      }
      const tema = this.temasDisponibles.find(t => t.id === temaId);
      if (tema) {
        metaThemeColor.setAttribute('content', tema.colorPrincipal);
      }
    }
  }

  restaurarConfiguracionPredeterminada() {
    // Tema predeterminado, modo automático (sistema)
    this.cambiarPreferenciaModo('sistema');
    this.cambiarTema('standard');
  }
}

================
File: src/app/app.component.html
================
<ion-app>
  <app-side-menu></app-side-menu>
  <ion-router-outlet id="main-content"></ion-router-outlet>
</ion-app>

================
File: src/app/app.component.spec.ts
================
import { TestBed } from '@angular/core/testing';
import { provideRouter } from '@angular/router';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  it('should create the app', async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
      providers: [provideRouter([])]
    }).compileComponents();
    
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });
});

================
File: src/app/app.component.ts
================
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import {
  IonApp, 
  IonRouterOutlet} from '@ionic/angular/standalone';
import { SidemenuComponent } from './components/sidemenu/sidemenu.component';
import { TemaService } from './services/tema.service';
import { Keyboard } from '@capacitor/keyboard';
@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    IonApp,
    IonRouterOutlet,
    SidemenuComponent
],
  templateUrl: 'app.component.html',
  styleUrls: ['app.component.scss'],
})
export class AppComponent {
  
  constructor(private temaService: TemaService) {}
}

================
File: src/app/app.routes.ts
================
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: '',
    redirectTo: 'login',
    pathMatch: 'full',
  },
  {
    path: 'login',
    loadComponent: () => import('./pages/login/login.page').then(m => m.LoginPage)
  },
  {
    path: 'signin',
    loadComponent: () => import('./pages/signin/signin.page').then(m => m.SigninPage)
  },
  {
    path: 'album',
    loadComponent: () => import('./pages/album/album.page').then(m => m.AlbumPage)
  },
  {
    path: 'conf',
    loadComponent: () => import('./pages/conf/conf.page').then(m => m.ConfPage)
  },
  {
    path: 'apariencia',
    loadComponent: () => import('./pages/apariencia/apariencia.page').then( m => m.AparienciaPage)
  },
  {
    path: 'chat/:id',
    loadComponent: () => import('./pages/chat/chat.page').then( m => m.ChatPage)
  },
  {
    path: 'tabs',
    loadComponent: () => import('./pages/tabs/tabs.page').then(m => m.TabsPage),
    children: [
      {
        path: 'home',
        loadComponent: () => import('./pages/home/home.page').then(m => m.HomePage)
      },
      {
        path: 'friends',
        loadComponent: () => import('./pages/friends/friends.page').then(m => m.FriendsPage)
      },
      {
        path: '',
        redirectTo: '/tabs/home',
        pathMatch: 'full'
      }
    ]
  },
  {
    path: '**',
    redirectTo: '/tabs/home',
    pathMatch: 'full'
  }
];

================
File: src/assets/shapes.svg
================
<svg width="350" height="140" xmlns="http://www.w3.org/2000/svg" style="background:#f6f7f9"><g fill="none" fill-rule="evenodd"><path fill="#F04141" style="mix-blend-mode:multiply" d="M61.905-34.23l96.194 54.51-66.982 54.512L22 34.887z"/><circle fill="#10DC60" style="mix-blend-mode:multiply" cx="155.5" cy="135.5" r="57.5"/><path fill="#3880FF" style="mix-blend-mode:multiply" d="M208.538 9.513l84.417 15.392L223.93 93.93z"/><path fill="#FFCE00" style="mix-blend-mode:multiply" d="M268.625 106.557l46.332-26.75 46.332 26.75v53.5l-46.332 26.75-46.332-26.75z"/><circle fill="#7044FF" style="mix-blend-mode:multiply" cx="299.5" cy="9.5" r="38.5"/><rect fill="#11D3EA" style="mix-blend-mode:multiply" transform="rotate(-60 148.47 37.886)" x="143.372" y="-7.056" width="10.196" height="89.884" rx="5.098"/><path d="M-25.389 74.253l84.86 8.107c5.498.525 9.53 5.407 9.004 10.905a10 10 0 0 1-.057.477l-12.36 85.671a10.002 10.002 0 0 1-11.634 8.42l-86.351-15.226c-5.44-.959-9.07-6.145-8.112-11.584l13.851-78.551a10 10 0 0 1 10.799-8.219z" fill="#7044FF" style="mix-blend-mode:multiply"/><circle fill="#0CD1E8" style="mix-blend-mode:multiply" cx="273.5" cy="106.5" r="20.5"/></g></svg>

================
File: src/environments/environment.prod.ts
================
export const environment = {
  production: true,
  apiUrl:'https://apirest.saicasl.eu/api3/api/public/',
};

================
File: src/environments/environment.ts
================
// This file can be replaced during build by using the `fileReplacements` array.
// `ng build` replaces `environment.ts` with `environment.prod.ts`.
// The list of file replacements can be found in `angular.json`.

export const environment = {
  production: false,
  apiUrl:'https://apirest.saicasl.eu/api3/api/public/',
};

/*
 * For easier debugging in development mode, you can import the following file
 * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.
 *
 * This import should be commented out in production mode because it will have a negative impact
 * on performance if an error is thrown.
 */
// import 'zone.js/plugins/zone-error';  // Included with Angular CLI.


================
File: src/index.html
================
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Ionic App</title>

  <base href="/" />

  <meta name="color-scheme" content="light dark" />
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="format-detection" content="telephone=no" />
  <meta name="msapplication-tap-highlight" content="no" />

  <link rel="icon" type="image/png" href="assets/icon/favicon.png" />

  <!-- add to homescreen for ios -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
</head>

<body>
  <app-root></app-root>
</body>

</html>

================
File: src/main.ts
================
import { bootstrapApplication } from '@angular/platform-browser';
import {
  RouteReuseStrategy,
  provideRouter,
  withPreloading,
  PreloadAllModules,
} from '@angular/router';
import {
  IonicRouteStrategy,
  provideIonicAngular,
} from '@ionic/angular/standalone';

import { routes } from './app/app.routes';
import { AppComponent } from './app/app.component';
import { initializeApp, provideFirebaseApp } from '@angular/fire/app';
import { getAuth, provideAuth } from '@angular/fire/auth';
import {
  getAnalytics,
  provideAnalytics,
  ScreenTrackingService,
  UserTrackingService,
} from '@angular/fire/analytics';
import {
  initializeAppCheck,
  ReCaptchaEnterpriseProvider,
  provideAppCheck,
} from '@angular/fire/app-check';
import { getFirestore, provideFirestore } from '@angular/fire/firestore';
import { getDatabase, provideDatabase } from '@angular/fire/database';
import { getFunctions, provideFunctions } from '@angular/fire/functions';
import { getMessaging, provideMessaging } from '@angular/fire/messaging';
import { getPerformance, providePerformance } from '@angular/fire/performance';
import { getStorage, provideStorage } from '@angular/fire/storage';
import {
  getRemoteConfig,
  provideRemoteConfig,
} from '@angular/fire/remote-config';
import { getVertexAI, provideVertexAI } from '@angular/fire/vertexai';
import { IonIcon } from '@ionic/angular';
import { addIcons } from 'ionicons';
import {
  lockClosed,
  mail,
  logoGoogle,
  logoFacebook,
  eye,
} from 'ionicons/icons';
import { HttpClientModule } from '@angular/common/http';
import { importProvidersFrom } from '@angular/core';
addIcons({
  'lock-closed': lockClosed,
  mail: mail,
  'logo-google': logoGoogle,
  'logo-facebook': logoFacebook,
  eye: eye,
});

bootstrapApplication(AppComponent, {
  providers: [
    { provide: RouteReuseStrategy, useClass: IonicRouteStrategy },
    provideIonicAngular(),
    provideRouter(routes, withPreloading(PreloadAllModules)),
    importProvidersFrom(HttpClientModule),
    provideFirebaseApp(() =>
      initializeApp({
        projectId: 'amuzik-38d5c',
        appId: '1:142614205335:web:919e66396d143fc658ead2',
        storageBucket: 'amuzik-38d5c.firebasestorage.app',
        apiKey: 'AIzaSyAxqDUI3mkgl9lRctgmqmIfPMv-HRMQ0BE',
        authDomain: 'amuzik-38d5c.firebaseapp.com',
        messagingSenderId: '142614205335',
        measurementId: 'G-YGSB2ZZGX4',
      })
    ),
    provideAuth(() => getAuth()),
    provideAnalytics(() => getAnalytics()),
    ScreenTrackingService,
    UserTrackingService,
    provideAppCheck(() => {
      const provider = new ReCaptchaEnterpriseProvider(
        '6LejIgUrAAAAAIXTlu4xLwSRS8cych1C5hOOPR7r'
      );
      return initializeAppCheck(undefined, {
        provider,
        isTokenAutoRefreshEnabled: true,
      });
    }),
    provideFirestore(() => getFirestore()),
    provideDatabase(() => getDatabase()),
    provideFunctions(() => getFunctions()),
    provideMessaging(() => getMessaging()),
    providePerformance(() => getPerformance()),
    provideStorage(() => getStorage()),
    provideRemoteConfig(() => getRemoteConfig()),
    provideVertexAI(() => getVertexAI()),
  ],
});

================================================================
End of Codebase
================================================================
